{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap f47051289bb9596d8e6b","webpack:///./src/index.js","webpack:///./src/vector/index.js","webpack:///./src/objects/geometric-object.js","webpack:///./src/objects/index.js","webpack:///./src/objects/sphere.js","webpack:///./src/renderer.js","webpack:///./src/vector/vector-objects.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","generateScene","progress","scene","camera","point","_vector2","new","fieldOfView","direction","lights","objects","_objects","Sphere","center","radius","color","material","specular","lambert","ambient","Math","sin","cos","_vector","_renderer","_renderer2","canvas","document","getElementById","width","height","style","cssText","renderer","enableSampling","tick","onclick","play","bind","stop","Object","defineProperty","value","_vectorObjects","_vectorObjects2","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","GeometricObject","this","undefined","_sphere","_sphere2","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","_geometricObject","_geometricObject2","_GeometricObject","_ref","_this","getPrototypeOf","ray","eyeToCenter","sub","origin","v","dot","eoDot","discriminant","sqrt","pos","normalize","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","push","err","Array","isArray","Renderer","generateSceneCallback","arguments","_ref$traceDepthLimit","traceDepthLimit","_ref$enableSampling","_ref$numSamples","numSamples","context","getContext","data","getImageData","isPlaying","time","_canvas","eyeVector","vpRight","cross","UP","vpUp","fovRadians","PI","heightWidthRatio","halfWidth","tan","halfHeight","cameraWidth","cameraHeight","pixelWidth","pixelHeight","x","y","copy","ZERO","n","q","xv","random","yv","xComp","mult","yComp","add3","add","trace","div","index","z","putImageData","depth","_intersectScene","intersectScene","_intersectScene2","dist","object","Infinity","WHITE","pointAtTime","surface","calculateNormal","reduce","closest","calculateIntersection","normal","lambertAmount","lightPoint","isLightVisible","contribution","reflectedRay","reflectThrough","reflectedColor","min","light","_intersectScene3","_intersectScene4","render","requestAnimationFrame","Vector","a","b","t","mag","angleBetween","acos","d","equal","lerp","amount","setMag","limit","max","magSq","heading","atan2","rotate","angle","newHeading","toString","toArray"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,IAGAV,EAAA,KDMM,SAASI,EAAQD,EAASH,GAE/B,YAYA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GE9CxF,QAASG,GAAcC,GACrB,GAAMC,IACJC,QACEC,MAAOC,EAAAN,QAAOO,IAAI,EAAK,IAAK,IAC5BC,YAAa,GACbC,UAAWH,EAAAN,QAAOO,IAAI,EAAK,EAAK,IAElCG,QAASJ,EAAAN,QAAOO,KAAI,IAAK,GAAK,KAC9BI,SACE,GAAAC,GAAAC,QACEC,OAAQR,EAAAN,QAAOO,IAAI,EAAG,KAAK,GAC3BQ,OAAQ,EACRC,MAAOV,EAAAN,QAAOO,IAAI,IAAK,IAAK,KAC5BU,UACEC,SAAU,GACVC,QAAS,GACTC,QAAS,MAGb,GAAAR,GAAAC,QACEC,OAAQR,EAAAN,QAAOO,IAA+B,IAA3Bc,KAAKC,IAAe,GAAXpB,GAAuB,GAAG,EAAiC,IAA3BmB,KAAKE,IAAe,GAAXrB,IACrEa,OAAQ,GACRC,MAAOV,EAAAN,QAAOO,IAAI,IAAK,IAAK,KAC5BU,UACEC,SAAU,GACVC,QAAS,GACTC,QAAS,KAGb,GAAAR,GAAAC,QACEC,OAAQR,EAAAN,QAAOO,IAA+B,EAA3Bc,KAAKC,IAAe,GAAXpB,GAAqB,GAAG,EAAiC,EAA3BmB,KAAKE,IAAe,GAAXrB,IACnEa,OAAQ,GACRC,MAAOV,EAAAN,QAAOO,IAAI,IAAK,IAAK,KAC5BU,UACEC,SAAU,GACVC,QAAS,GACTC,QAAS,OAMjB,OAAOjB,GAtDT,GAAAqB,GAAAtC,EAAA,GFkDKoB,EAAWT,EAAuB2B,GEjDvCZ,EAAA1B,EAAA,GACAuC,EAAAvC,EAAA,GFsDKwC,EAAa7B,EAAuB4B,GEpDnCE,EAASC,SAASC,eAAe,UACjCC,EAAQ,IACRC,EAAS,GAEfJ,GAAOG,MAAQA,EACfH,EAAOI,OAASA,EAChBJ,EAAOK,MAAMC,QAAb,SAAyC,EAARH,EAAjC,aAAkE,EAATC,EAAzD,IA+CA,IAAMG,GAAW,GAAAR,GAAA1B,QAAa2B,EAAQ1B,GAAiBkC,gBAAgB,GAEvED,GAASE,OAETR,SAASC,eAAe,QAAQQ,QAAUH,EAASI,KAAKC,KAAKL,GAC7DN,SAASC,eAAe,QAAQQ,QAAUH,EAASM,KAAKD,KAAKL,IFwDvD,SAAS5C,EAAQD,EAASH,GAE/B,YAUA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GARvF2C,OAAOC,eAAerD,EAAS,cAC7BsD,OAAO,GG1HV,IAAAC,GAAA1D,EAAA,GH+HK2D,EAAkBhD,EAAuB+C,EAI7CvD,GAAQW,QAAU6C,EAAgB7C,SAI7B,SAASV,EAAQD,GAEtB,YAQA,SAASyD,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCANhHR,OAAOC,eAAerD,EAAS,cAC7BsD,OAAO,GAGT,IAAIO,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMlB,OAAOC,eAAeU,EAAQI,EAAWI,IAAKJ,IAAiB,MAAO,UAAUR,EAAaa,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBH,EAAYe,UAAWF,GAAiBC,GAAaX,EAAiBH,EAAac,GAAqBd,MIhJ5gBgB,EJoJE,WInJrB,QAAAA,GAAYhD,EAAOC,GAAU6B,EAAAmB,KAAAD,GAC3BC,KAAKjD,MAAQA,EACbiD,KAAKhD,SAAWA,EJqKjB,MAZAiC,GAAac,IACXJ,IAAK,wBACLjB,MAAO,eAIPiB,IAAK,kBACLjB,MAAO,gBAKFqB,IAGT3E,GAAQW,QI3KYgE,GJ+Kf,SAAS1E,EAAQD,EAASH,GAE/B,YAWA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GATvF2C,OAAOC,eAAerD,EAAS,cAC7BsD,OAAO,IAETtD,EAAQwB,OAASqD,MKtLlB,IAAAC,GAAAjF,EAAA,GL0LKkF,EAAWvE,EAAuBsE,EAItC9E,GK3LCwB,OL2LgBuD,EAASpE,SAIrB,SAASV,EAAQD,EAASH,GAE/B,YAgBA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASgD,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASoB,GAA2BC,EAAM7E,GAAQ,IAAK6E,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAO9E,GAAyB,gBAATA,IAAqC,kBAATA,GAA8B6E,EAAP7E,EAElO,QAAS+E,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIzB,WAAU,iEAAoEyB,GAAeD,GAASV,UAAYtB,OAAOkC,OAAOD,GAAcA,EAAWX,WAAaa,aAAejC,MAAO8B,EAAUhB,YAAY,EAAOE,UAAU,EAAMD,cAAc,KAAegB,IAAYjC,OAAOoC,eAAiBpC,OAAOoC,eAAeJ,EAAUC,GAAcD,EAASK,UAAYJ,GApBjejC,OAAOC,eAAerD,EAAS,cAC7BsD,OAAO,GAGT,IAAIO,GAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMlB,OAAOC,eAAeU,EAAQI,EAAWI,IAAKJ,IAAiB,MAAO,UAAUR,EAAaa,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBH,EAAYe,UAAWF,GAAiBC,GAAaX,EAAiBH,EAAac,GAAqBd,MM1MjiB+B,EAAA7F,EAAA,GN8MK8F,EAAoBnF,EAAuBkF,GM7MhDvD,EAAAtC,EAAA,GNiNKoB,EAAWT,EAAuB2B,GM/MlBX,ENyNP,SAAUoE,GMxNtB,QAAApE,GAAAqE,GAAiD,GAAnCpE,GAAmCoE,EAAnCpE,OAAQC,EAA2BmE,EAA3BnE,OAAQC,EAAmBkE,EAAnBlE,MAAOC,EAAYiE,EAAZjE,QAAY6B,GAAAmB,KAAApD,EAAA,IAAAsE,GAAAd,EAAAJ,MAAApD,EAAAiE,WAAArC,OAAA2C,eAAAvE,IAAApB,KAAAwE,KACzCjD,EAAOC,GADkC,OAE/CkE,GAAKrE,OAASA,EACdqE,EAAKpE,OAASA,EAHiCoE,EN+PhD,MAtCAX,GAAU3D,EAAQoE,GAiBlB/B,EAAarC,IACX+C,IAAK,wBACLjB,MAAO,SMtOY0C,GACpB,GAAMC,GAAchF,EAAAN,QAAOuF,IAAItB,KAAKnD,OAAQuE,EAAIG,QAC1CC,EAAInF,EAAAN,QAAO0F,IAAIJ,EAAaD,EAAI5E,WAChCkF,EAAQrF,EAAAN,QAAO0F,IAAIJ,EAAaA,GAChCM,EAAgB3B,KAAKlD,OAASkD,KAAKlD,OAAU4E,EAASF,EAAIA,CAEhE,MAAIG,EAAe,GAInB,MAAOH,GAAIpE,KAAKwE,KAAKD,MNyOpBhC,IAAK,kBACLjB,MAAO,SMvOMmD,GACd,MAAOxF,GAAAN,QAAO+F,UAAUzF,EAAAN,QAAOuF,IAAIO,EAAK7B,KAAKnD,aN2OvCD,GACPmE,EAAkBhF,QAEpBX,GAAQW,QMnQYa,GNuQf,SAASvB,EAAQD,EAASH,GAE/B,YAcA,SAASW,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,QAASF,GAEvF,QAASgD,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAdhHR,OAAOC,eAAerD,EAAS,cAC7BsD,OAAO,GAGT,IAAIqD,GAAiB,WAAc,QAASC,GAAcC,EAAK5C,GAAK,GAAI6C,MAAeC,GAAK,EAAUC,GAAK,EAAWC,EAAKpC,MAAW,KAAM,IAAK,GAAiCqC,GAA7BC,EAAKN,EAAIO,OAAOC,cAAmBN,GAAMG,EAAKC,EAAGG,QAAQC,QAAoBT,EAAKU,KAAKN,EAAG5D,QAAYW,GAAK6C,EAAK5C,SAAWD,GAA3D8C,GAAK,IAAoE,MAAOU,GAAOT,GAAK,EAAMC,EAAKQ,EAAO,QAAU,KAAWV,GAAMI,EAAW,QAAGA,EAAW,SAAO,QAAU,GAAIH,EAAI,KAAMC,IAAQ,MAAOH,GAAQ,MAAO,UAAUD,EAAK5C,GAAK,GAAIyD,MAAMC,QAAQd,GAAQ,MAAOA,EAAY,IAAIO,OAAOC,WAAYjE,QAAOyD,GAAQ,MAAOD,GAAcC,EAAK5C,EAAa,MAAM,IAAIL,WAAU,4DAEllBC,EAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMlB,OAAOC,eAAeU,EAAQI,EAAWI,IAAKJ,IAAiB,MAAO,UAAUR,EAAaa,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBH,EAAYe,UAAWF,GAAiBC,GAAaX,EAAiBH,EAAac,GAAqBd,MOpRjiBxB,EAAAtC,EAAA,GPwRKoB,EAAWT,EAAuB2B,GOtRlByF,EP4RL,WO3Rd,QAAAA,GAAYtF,EAAQuF,GAAuF,GAAAhC,GAAAiC,UAAA5D,OAAA,GAAAW,SAAAiD,UAAA,GAAAA,UAAA,MAAAC,EAAAlC,EAA9DmC,kBAA8DnD,SAAAkD,EAA9C,EAA8CA,EAAAE,EAAApC,EAA3C/C,iBAA2C+B,SAAAoD,KAAAC,EAAArC,EAArBsC,aAAqBtD,SAAAqD,EAAV,EAAUA,CAAAzE,GAAAmB,KAAAgD,EAAA,IACjGnF,GAAkBH,EAAlBG,MAAOC,EAAWJ,EAAXI,MAEfkC,MAAKtC,OAASA,EACdsC,KAAKwD,QAAU9F,EAAO+F,WAAW,MACjCzD,KAAK0D,KAAO1D,KAAKwD,QAAQG,aAAa,EAAG,EAAG9F,EAAOC,GACnDkC,KAAKhE,cAAgBiH,EACrBjD,KAAKoD,gBAAkBA,EACvBpD,KAAK9B,eAAiBA,EACtB8B,KAAKuD,WAAaA,EAClBvD,KAAK4D,WAAY,EACjB5D,KAAK6D,KAAO,EP6eb,MAlMA5E,GAAa+D,IACXrD,IAAK,SACLjB,MAAO,SO1SHxC,GAsBL,IAAK,GArBCC,GAASD,EAAMC,OADT2H,EAEc9D,KAAKtC,OAAvBG,EAFIiG,EAEJjG,MAAOC,EAFHgG,EAEGhG,OACT4F,EAAO1D,KAAK0D,KAIZK,EAAY1H,EAAAN,QAAO+F,UAAUzF,EAAAN,QAAOuF,IAAInF,EAAOK,UAAWL,EAAOC,QACjE4H,EAAU3H,EAAAN,QAAO+F,UAAUzF,EAAAN,QAAOkI,MAAMF,EAAW1H,EAAAN,QAAOmI,KAC1DC,EAAO9H,EAAAN,QAAO+F,UAAUzF,EAAAN,QAAOkI,MAAMD,EAASD,IAE9CK,EAAahH,KAAKiH,IAAMlI,EAAOI,YAAc,GAAK,IAClD+H,EAAmBxG,EAASD,EAC5B0G,EAAYnH,KAAKoH,IAAIJ,GACrBK,EAAaH,EAAmBC,EAChCG,EAA0B,EAAZH,EACdI,EAA4B,EAAbF,EACfG,EAAaF,GAAe7G,EAAQ,GACpCgH,EAAcF,GAAgB7G,EAAS,GAEvCsD,GAAQG,OAAQpF,EAAOC,MAAOI,UAAWH,EAAAN,QAAOO,OAE7CwI,EAAI,EAAGA,EAAIjH,EAAOiH,IACzB,IAAK,GAAIC,GAAI,EAAGA,EAAIjH,EAAQiH,IAAK,CAC/B,GAAIhI,GAAQV,EAAAN,QAAOiJ,KAAK3I,EAAAN,QAAOkJ,KAE/B,IAAIjF,KAAK9B,eAAgB,CAGvB,IAAK,GAFCgH,GAAI9H,KAAKwE,KAAK5B,KAAKuD,YAEhB5H,EAAI,EAAGA,EAAIuJ,EAAGvJ,IACrB,IAAK,GAAIwJ,GAAI,EAAGA,EAAID,EAAGC,IAAK,CAK1B,GAAMC,GAAKR,GAAcE,EAAIP,GAAaY,EAAI/H,KAAKiI,UAAYH,GAAKX,EAC9De,EAAKT,GAAeE,EAAIN,GAAc9I,EAAIyB,KAAKiI,UAAYH,GAAKT,EAChEc,EAAQlJ,EAAAN,QAAOyJ,KAAKxB,EAASoB,GAC7BK,EAAQpJ,EAAAN,QAAOyJ,KAAKrB,EAAMmB,EAEhClE,GAAI5E,UAAYH,EAAAN,QAAO+F,UAAUzF,EAAAN,QAAO2J,KAAKH,EAAOE,EAAO1B,IAE3DhH,EAAQV,EAAAN,QAAO4J,IAAI5I,EAAOiD,KAAK4F,MAAMxE,EAAKlF,EAAO,IAIrDa,EAAQV,EAAAN,QAAO8J,IAAI9I,EAAOiD,KAAKuD,gBAE1B,CACL,GAAM6B,GAAKR,GAAcE,EAAIP,GAAaA,EACpCe,EAAKT,GAAeE,EAAIN,GAAcA,EACtCc,EAAQlJ,EAAAN,QAAOyJ,KAAKxB,EAASoB,GAC7BK,EAAQpJ,EAAAN,QAAOyJ,KAAKrB,EAAMmB,EAEhClE,GAAI5E,UAAYH,EAAAN,QAAO+F,UAAUzF,EAAAN,QAAO2J,KAAKH,EAAOE,EAAO1B,IAC3DhH,EAAQiD,KAAK4F,MAAMxE,EAAKlF,EAAO,GAGjC,GAAM4J,GAAa,EAAJhB,EAAUC,EAAIlH,EAAQ,CACrC6F,GAAKA,KAAKoC,EAAQ,GAAK/I,EAAM+H,EAC7BpB,EAAKA,KAAKoC,EAAQ,GAAK/I,EAAMgI,EAC7BrB,EAAKA,KAAKoC,EAAQ,GAAK/I,EAAMgJ,EAC7BrC,EAAKA,KAAKoC,EAAQ,GAAK,IAI3B9F,KAAKwD,QAAQwC,aAAatC,EAAM,EAAG,MP+SlC/D,IAAK,QACLjB,MAAO,SO7SJ0C,EAAKlF,EAAO+J,GAChB,KAAIA,EAAQjG,KAAKoD,iBAAjB,CADuB,GAAA8C,GAKAlG,KAAKmG,eAAe/E,EAAKlF,GALzBkK,EAAArE,EAAAmE,EAAA,GAKhBG,EALgBD,EAAA,GAKVE,EALUF,EAAA,EAOvB,IAAIC,IAASE,IACX,MAAOlK,GAAAN,QAAOiJ,KAAK3I,EAAAN,QAAOyK,MAO5B,IAAMC,GAAcpK,EAAAN,QAAO4J,IAAItJ,EAAAN,QAAOyJ,KAAKpE,EAAI5E,UAAW6J,GAAOjF,EAAIG,OAErE,OAAOvB,MAAK0G,QAAQtF,EAAKlF,EAAOoK,EAAQG,EAAaH,EAAOK,gBAAgBF,GAAcR,OPmTzFtG,IAAK,iBACLjB,MAAO,SOjTK0C,EAAKlF,GAClB,MAAOA,GAAMQ,QAAQkK,OAAO,SAASC,EAASP,GAC5C,GAAMD,GAAOC,EAAOQ,sBAAsB1F,EAC1C,OAAgBnB,UAAToG,GAAsBA,EAAOQ,EAAQ,IAAMR,EAAMC,GAAUO,IAChEN,IAAU,UPoTb5G,IAAK,UACLjB,MAAO,SOlTF0C,EAAKlF,EAAOoK,EAAQG,EAAaM,EAAQd,GAC/C,GAAIlJ,GAAQV,EAAAN,QAAOiJ,KAAK3I,EAAAN,QAAOkJ,MAC3B+B,EAAgB,CAEpB,IAAIV,EAAOtJ,SAASE,QAClB,IAAK,GAAImC,GAAI,EAAGA,EAAInD,EAAMO,OAAO6C,OAAQD,IAAK,CAC5C,GAAM4H,GAAa/K,EAAMO,OAAO4C,EAIhC,IAAKW,KAAKkH,eAAeT,EAAavK,EAAO+K,GAA7C,CAOA,GAAME,GAAe9K,EAAAN,QAAO0F,IAAIpF,EAAAN,QAAO+F,UAAUzF,EAAAN,QAAOuF,IAAI2F,EAAYR,IAAeM,EAGnFI,GAAe,IACjBH,GAAiBG,IAKvB,GAAIb,EAAOtJ,SAASC,SAAU,CAK5B,GAAMmK,IAAiB7F,OAAQkF,EAAajK,UAAWH,EAAAN,QAAOsL,eAAejG,EAAI5E,UAAWuK,IACtFO,EAAiBtH,KAAK4F,MAAMwB,EAAclL,EAAO+J,EAAQ,EAC3DqB,KACFvK,EAAQV,EAAAN,QAAO4J,IAAI5I,EAAOV,EAAAN,QAAOyJ,KAAK8B,EAAgBhB,EAAOtJ,SAASC,YAa1E,MAPA+J,GAAgB5J,KAAKmK,IAAI,EAAGP,GAK5BjK,EAAQV,EAAAN,QAAO4J,IAAI5I,EAAOV,EAAAN,QAAOyJ,KAAKc,EAAOvJ,MAAOiK,EAAgBV,EAAOtJ,SAASE,UACpFH,EAAQV,EAAAN,QAAO4J,IAAI5I,EAAOV,EAAAN,QAAOyJ,KAAKc,EAAOvJ,MAAOuJ,EAAOtJ,SAASG,aPsTnEwC,IAAK,iBACLjB,MAAO,SOnTKtC,EAAOF,EAAOsL,GAC3B,GAAMpG,IAAQG,OAAQnF,EAAOI,UAAWH,EAAAN,QAAO+F,UAAUzF,EAAAN,QAAOuF,IAAIlF,EAAOoL,KADzCC,EAEnBzH,KAAKmG,eAAe/E,EAAKlF,GAFNwL,EAAA3F,EAAA0F,EAAA,GAE3BpB,EAF2BqB,EAAA,EAGlC,OAAOrB,IAAO,QP0Tb1G,IAAK,OACLjB,MAAO,WOvTR,GAAMxC,GAAQ8D,KAAKhE,cAAcgE,KAAK6D,KACtC7D,MAAK6D,OAEL7D,KAAK2H,OAAOzL,GAER8D,KAAK4D,WACPgE,sBAAsB5H,KAAK7B,KAAKG,KAAK0B,UP4TtCL,IAAK,OACLjB,MAAO,WOxTJsB,KAAK4D,YAGT5D,KAAK4D,WAAY,EACjBgE,sBAAsB5H,KAAK7B,KAAKG,KAAK0B,WP4TpCL,IAAK,OACLjB,MAAO,WOzTRsB,KAAK4D,WAAY,MP8TXZ,IAGT5H,GAAQW,QO5fYiH,GPggBf,SAAS3H,EAAQD,GAEtB,YAEAoD,QAAOC,eAAerD,EAAS,cAC7BsD,OAAO,GQxfV,IAAMmJ,KAGNA,GAAO3D,IAAOY,EAAG,EAAKC,EAAG,EAAKgB,EAAG,GACjC8B,EAAO5C,MAASH,EAAG,EAAKC,EAAG,EAAKgB,EAAG,GACnC8B,EAAOrB,OAAU1B,EAAG,IAAKC,EAAG,IAAKgB,EAAG,KAEpC8B,EAAOvL,IAAM,WAA8B,GAArBwI,GAAqB5B,UAAA5D,OAAA,GAAAW,SAAAiD,UAAA,GAAAA,UAAA,GAAjB,EAAG6B,EAAc7B,UAAA5D,OAAA,GAAAW,SAAAiD,UAAA,GAAAA,UAAA,GAAV,EAAG6C,EAAO7C,UAAA5D,OAAA,GAAAW,SAAAiD,UAAA,GAAAA,UAAA,GAAH,CACtC,QAAS4B,EAAGA,EAAGC,EAAGA,EAAGgB,EAAGA,IAG1B8B,EAAO7C,KAAO,SAAS8C,GACrB,OAAShD,EAAGgD,EAAEhD,EAAGC,EAAG+C,EAAE/C,EAAGgB,EAAG+B,EAAE/B,IAGhC8B,EAAOpG,IAAM,SAASqG,EAAGC,GACvB,MAAQD,GAAEhD,EAAIiD,EAAEjD,EAAMgD,EAAE/C,EAAIgD,EAAEhD,EAAM+C,EAAE/B,EAAIgC,EAAEhC,GAG9C8B,EAAO5D,MAAQ,SAAS6D,EAAGC,GACzB,OACEjD,EAAIgD,EAAE/C,EAAIgD,EAAEhC,EAAM+B,EAAE/B,EAAIgC,EAAEhD,EAC1BA,EAAI+C,EAAE/B,EAAIgC,EAAEjD,EAAMgD,EAAEhD,EAAIiD,EAAEhC,EAC1BA,EAAI+B,EAAEhD,EAAIiD,EAAEhD,EAAM+C,EAAE/C,EAAIgD,EAAEjD,IAI9B+C,EAAOrC,KAAO,SAASsC,EAAGE,GACxB,OACElD,EAAGgD,EAAEhD,EAAIkD,EACTjD,EAAG+C,EAAE/C,EAAIiD,EACTjC,EAAG+B,EAAE/B,EAAIiC,IAIbH,EAAOhC,IAAM,SAASiC,EAAGE,GACvB,OACElD,EAAGgD,EAAEhD,EAAIkD,EACTjD,EAAG+C,EAAE/C,EAAIiD,EACTjC,EAAG+B,EAAE/B,EAAIiC,IAIbH,EAAO/F,UAAY,SAASgG,GAC1B,GAAMG,GAAMJ,EAAOI,IAAIH,EACvB,OAAe,KAARG,EAAYH,EAAID,EAAOhC,IAAIiC,EAAGG,IAKvCJ,EAAOlC,IAAM,SAASmC,EAAGC,GACvB,OACEjD,EAAGgD,EAAEhD,EAAIiD,EAAEjD,EACXC,EAAG+C,EAAE/C,EAAIgD,EAAEhD,EACXgB,EAAG+B,EAAE/B,EAAIgC,EAAEhC,IAQf8B,EAAOnC,KAAO,SAASoC,EAAGC,EAAGrM,GAC3B,OACEoJ,EAAGgD,EAAEhD,EAAIiD,EAAEjD,EAAIpJ,EAAEoJ,EACjBC,EAAG+C,EAAE/C,EAAIgD,EAAEhD,EAAIrJ,EAAEqJ,EACjBgB,EAAG+B,EAAE/B,EAAIgC,EAAEhC,EAAIrK,EAAEqK,IAKrB8B,EAAOvG,IAAM,SAASwG,EAAGC,GACvB,OACEjD,EAAGgD,EAAEhD,EAAIiD,EAAEjD,EACXC,EAAG+C,EAAE/C,EAAIgD,EAAEhD,EACXgB,EAAG+B,EAAE/B,EAAIgC,EAAEhC,IAKf8B,EAAOI,IAAM,SAASH,GACpB,MAAO1K,MAAKwE,KAAKiG,EAAOpG,IAAIqG,EAAGA,KAGjCD,EAAOK,aAAe,SAASJ,EAAGC,GAChC,MAAO3K,MAAK+K,KAAKN,EAAOpG,IAAIqG,EAAGC,IAAMF,EAAOI,IAAIH,GAAKD,EAAOI,IAAIF,MAMlEF,EAAOR,eAAiB,SAASS,EAAGf,GAClC,GAAMqB,GAAIP,EAAOrC,KAAKuB,EAAQc,EAAOpG,IAAIqG,EAAGf,GAC5C,OAAOc,GAAOvG,IAAIuG,EAAOrC,KAAK4C,EAAG,GAAIN,IAGvCD,EAAOxB,KAAO,SAASyB,EAAGC,GACxB,GAAMK,GAAIP,EAAOvG,IAAIyG,EAAGD,EACxB,OAAOD,GAAOI,IAAIG,IAGpBP,EAAOQ,MAAQ,SAASP,EAAGC,GACzB,MAAOD,GAAEhD,IAAMiD,EAAEjD,GAAKgD,EAAE/C,IAAMgD,EAAEhD,GAAK+C,EAAE/B,IAAMgC,EAAEhC,GAGjD8B,EAAOS,KAAO,SAASR,EAAGC,EAAGQ,GAC3B,OACEzD,EAAGgD,EAAEhD,GAAKiD,EAAEjD,EAAIgD,EAAEhD,GAAKyD,GAAU,EACjCxD,EAAG+C,EAAE/C,GAAKgD,EAAEhD,EAAI+C,EAAE/C,GAAKwD,GAAU,EACjCxC,EAAG+B,EAAE/B,GAAKgC,EAAEhC,EAAI+B,EAAE/B,GAAKwC,GAAU,IAIrCV,EAAOW,OAAS,SAASV,EAAG5C,GAC1B,MAAO2C,GAAOrC,KAAKqC,EAAO/F,UAAUgG,GAAI5C,IAG1C2C,EAAOY,MAAQ,SAASX,EAAGY,GACzB,GAAMC,GAAQd,EAAOpG,IAAIqG,EAAGA,EAC5B,OAAIa,GAAQD,EAAMA,EACTb,EAAOW,OAAOV,EAAGY,GAEjBZ,GAIXD,EAAOe,QAAU,SAASd,GACxB,MAAO1K,MAAKyL,MAAMf,EAAE/C,EAAG+C,EAAEhD,IAG3B+C,EAAOiB,OAAS,SAAShB,EAAGiB,GAC1B,GAAMC,GAAanB,EAAOe,QAAQd,GAAKiB,EACjCd,EAAMJ,EAAOI,IAAIH,EACvB,QACEhD,EAAG1H,KAAKE,IAAI0L,GAAcf,EAC1BlD,EAAG3H,KAAKC,IAAI2L,GAAcf,EAC1BlC,EAAG+B,EAAE/B,IAIT8B,EAAOoB,SAAW,SAASnB,GACzB,UAAWA,EAAEhD,EAAb,KAAmBgD,EAAE/C,EAArB,KAA2B+C,EAAE/B,EAA7B,KAGF8B,EAAOqB,QAAU,SAASpB,GACxB,OAAQA,EAAEhD,EAAGgD,EAAE/C,EAAG+C,EAAE/B,IRghBrB3K,EAAQW,QQ7gBM8L","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _vector = __webpack_require__(1);\n\t\n\tvar _vector2 = _interopRequireDefault(_vector);\n\t\n\tvar _objects = __webpack_require__(3);\n\t\n\tvar _renderer = __webpack_require__(5);\n\t\n\tvar _renderer2 = _interopRequireDefault(_renderer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar canvas = document.getElementById('canvas');\n\tvar width = 640 * 0.5;\n\tvar height = 480 * 0.5;\n\t\n\tcanvas.width = width;\n\tcanvas.height = height;\n\tcanvas.style.cssText = 'width:' + width * 2 + 'px;height:' + height * 2 + 'px';\n\t\n\tfunction generateScene(progress) {\n\t  var scene = {\n\t    camera: {\n\t      point: _vector2.default.new(0.0, 1.8, 10),\n\t      fieldOfView: 45,\n\t      direction: _vector2.default.new(0.0, 3.0, 0.0)\n\t    },\n\t    lights: [_vector2.default.new(-30, -10, 20)],\n\t    objects: [new _objects.Sphere({\n\t      center: _vector2.default.new(0, 3.5, -3),\n\t      radius: 3,\n\t      color: _vector2.default.new(155, 200, 155),\n\t      material: {\n\t        specular: 0.2,\n\t        lambert: 0.7,\n\t        ambient: 0.1\n\t      }\n\t    }), new _objects.Sphere({\n\t      center: _vector2.default.new(Math.sin(progress * 0.1) * 3.5, 2, -3 + Math.cos(progress * 0.1) * 3.5),\n\t      radius: 0.2,\n\t      color: _vector2.default.new(155, 155, 155),\n\t      material: {\n\t        specular: 0.1,\n\t        lambert: 0.9,\n\t        ambient: 0.0\n\t      }\n\t    }), new _objects.Sphere({\n\t      center: _vector2.default.new(Math.sin(progress * 0.2) * 4, 3, -3 + Math.cos(progress * 0.2) * 4),\n\t      radius: 0.1,\n\t      color: _vector2.default.new(255, 255, 255),\n\t      material: {\n\t        specular: 0.2,\n\t        lambert: 0.7,\n\t        ambient: 0.1\n\t      }\n\t    })]\n\t  };\n\t\n\t  return scene;\n\t}\n\t\n\tvar renderer = new _renderer2.default(canvas, generateScene, { enableSampling: false });\n\t\n\trenderer.tick();\n\t\n\tdocument.getElementById('play').onclick = renderer.play.bind(renderer);\n\tdocument.getElementById('stop').onclick = renderer.stop.bind(renderer);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _vectorObjects = __webpack_require__(6);\n\t\n\tvar _vectorObjects2 = _interopRequireDefault(_vectorObjects);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _vectorObjects2.default; // import VectorClass from './vector-class'\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar GeometricObject = function () {\n\t  function GeometricObject(color, material) {\n\t    _classCallCheck(this, GeometricObject);\n\t\n\t    this.color = color;\n\t    this.material = material;\n\t  }\n\t\n\t  _createClass(GeometricObject, [{\n\t    key: \"calculateIntersection\",\n\t    value: function calculateIntersection() {\n\t      return undefined;\n\t    }\n\t  }, {\n\t    key: \"calculateNormal\",\n\t    value: function calculateNormal() {\n\t      return undefined;\n\t    }\n\t  }]);\n\t\n\t  return GeometricObject;\n\t}();\n\t\n\texports.default = GeometricObject;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Sphere = undefined;\n\t\n\tvar _sphere = __webpack_require__(4);\n\t\n\tvar _sphere2 = _interopRequireDefault(_sphere);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.Sphere = _sphere2.default;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _geometricObject = __webpack_require__(2);\n\t\n\tvar _geometricObject2 = _interopRequireDefault(_geometricObject);\n\t\n\tvar _vector = __webpack_require__(1);\n\t\n\tvar _vector2 = _interopRequireDefault(_vector);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar Sphere = function (_GeometricObject) {\n\t  _inherits(Sphere, _GeometricObject);\n\t\n\t  function Sphere(_ref) {\n\t    var center = _ref.center,\n\t        radius = _ref.radius,\n\t        color = _ref.color,\n\t        material = _ref.material;\n\t\n\t    _classCallCheck(this, Sphere);\n\t\n\t    var _this = _possibleConstructorReturn(this, (Sphere.__proto__ || Object.getPrototypeOf(Sphere)).call(this, color, material));\n\t\n\t    _this.center = center;\n\t    _this.radius = radius;\n\t    return _this;\n\t  }\n\t\n\t  _createClass(Sphere, [{\n\t    key: 'calculateIntersection',\n\t    value: function calculateIntersection(ray) {\n\t      var eyeToCenter = _vector2.default.sub(this.center, ray.origin);\n\t      var v = _vector2.default.dot(eyeToCenter, ray.direction);\n\t      var eoDot = _vector2.default.dot(eyeToCenter, eyeToCenter);\n\t      var discriminant = this.radius * this.radius - eoDot + v * v;\n\t\n\t      if (discriminant < 0) {\n\t        return;\n\t      }\n\t\n\t      return v - Math.sqrt(discriminant);\n\t    }\n\t  }, {\n\t    key: 'calculateNormal',\n\t    value: function calculateNormal(pos) {\n\t      return _vector2.default.normalize(_vector2.default.sub(pos, this.center));\n\t    }\n\t  }]);\n\t\n\t  return Sphere;\n\t}(_geometricObject2.default);\n\t\n\texports.default = Sphere;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _vector = __webpack_require__(1);\n\t\n\tvar _vector2 = _interopRequireDefault(_vector);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Renderer = function () {\n\t  function Renderer(canvas, generateSceneCallback) {\n\t    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n\t        _ref$traceDepthLimit = _ref.traceDepthLimit,\n\t        traceDepthLimit = _ref$traceDepthLimit === undefined ? 3 : _ref$traceDepthLimit,\n\t        _ref$enableSampling = _ref.enableSampling,\n\t        enableSampling = _ref$enableSampling === undefined ? false : _ref$enableSampling,\n\t        _ref$numSamples = _ref.numSamples,\n\t        numSamples = _ref$numSamples === undefined ? 9 : _ref$numSamples;\n\t\n\t    _classCallCheck(this, Renderer);\n\t\n\t    var width = canvas.width,\n\t        height = canvas.height;\n\t\n\t\n\t    this.canvas = canvas;\n\t    this.context = canvas.getContext('2d');\n\t    this.data = this.context.getImageData(0, 0, width, height);\n\t    this.generateScene = generateSceneCallback;\n\t    this.traceDepthLimit = traceDepthLimit;\n\t    this.enableSampling = enableSampling;\n\t    this.numSamples = numSamples;\n\t    this.isPlaying = false;\n\t    this.time = 1;\n\t  }\n\t\n\t  _createClass(Renderer, [{\n\t    key: 'render',\n\t    value: function render(scene) {\n\t      var camera = scene.camera;\n\t      var _canvas = this.canvas,\n\t          width = _canvas.width,\n\t          height = _canvas.height;\n\t\n\t      var data = this.data;\n\t\n\t      // all the raytracing stuff goes here\n\t\n\t      var eyeVector = _vector2.default.normalize(_vector2.default.sub(camera.direction, camera.point)); // w (reversed?)\n\t      var vpRight = _vector2.default.normalize(_vector2.default.cross(eyeVector, _vector2.default.UP)); // u\n\t      var vpUp = _vector2.default.normalize(_vector2.default.cross(vpRight, eyeVector)); // v\n\t\n\t      var fovRadians = Math.PI * (camera.fieldOfView / 2) / 180;\n\t      var heightWidthRatio = height / width;\n\t      var halfWidth = Math.tan(fovRadians);\n\t      var halfHeight = heightWidthRatio * halfWidth;\n\t      var cameraWidth = halfWidth * 2;\n\t      var cameraHeight = halfHeight * 2;\n\t      var pixelWidth = cameraWidth / (width - 1);\n\t      var pixelHeight = cameraHeight / (height - 1);\n\t\n\t      var ray = { origin: camera.point, direction: _vector2.default.new() };\n\t\n\t      for (var x = 0; x < width; x++) {\n\t        for (var y = 0; y < height; y++) {\n\t          var color = _vector2.default.copy(_vector2.default.ZERO);\n\t\n\t          if (this.enableSampling) {\n\t            var n = Math.sqrt(this.numSamples);\n\t\n\t            for (var p = 0; p < n; p++) {\n\t              for (var q = 0; q < n; q++) {\n\t                // turn the raw pixel x and y values into values from -1 to 1\n\t                // and use these values to scale the facing-right and facing-up\n\t                // vectors so that we generate versions of the `eyeVector` that are\n\t                // skewed in each necessary direction.\n\t                var xv = pixelWidth * (x - halfWidth + (q + Math.random()) / n) - halfWidth;\n\t                var yv = pixelHeight * (y - halfHeight + (p + Math.random()) / n) - halfHeight;\n\t                var xComp = _vector2.default.mult(vpRight, xv);\n\t                var yComp = _vector2.default.mult(vpUp, yv);\n\t\n\t                ray.direction = _vector2.default.normalize(_vector2.default.add3(xComp, yComp, eyeVector));\n\t\n\t                color = _vector2.default.add(color, this.trace(ray, scene, 0));\n\t              }\n\t            }\n\t\n\t            color = _vector2.default.div(color, this.numSamples);\n\t          } else {\n\t            var _xv = pixelWidth * (x - halfWidth) - halfWidth;\n\t            var _yv = pixelHeight * (y - halfHeight) - halfHeight;\n\t            var _xComp = _vector2.default.mult(vpRight, _xv);\n\t            var _yComp = _vector2.default.mult(vpUp, _yv);\n\t\n\t            ray.direction = _vector2.default.normalize(_vector2.default.add3(_xComp, _yComp, eyeVector));\n\t            color = this.trace(ray, scene, 0);\n\t          }\n\t\n\t          var index = x * 4 + y * width * 4;\n\t          data.data[index + 0] = color.x;\n\t          data.data[index + 1] = color.y;\n\t          data.data[index + 2] = color.z;\n\t          data.data[index + 3] = 255;\n\t        }\n\t      }\n\t\n\t      this.context.putImageData(data, 0, 0);\n\t    }\n\t  }, {\n\t    key: 'trace',\n\t    value: function trace(ray, scene, depth) {\n\t      if (depth > this.traceDepthLimit) {\n\t        return;\n\t      }\n\t\n\t      var _intersectScene = this.intersectScene(ray, scene),\n\t          _intersectScene2 = _slicedToArray(_intersectScene, 2),\n\t          dist = _intersectScene2[0],\n\t          object = _intersectScene2[1];\n\t\n\t      if (dist === Infinity) {\n\t        return _vector2.default.copy(_vector2.default.WHITE);\n\t      }\n\t\n\t      // The pointAtTime is another way of saying the 'intersection point'\n\t      // of this ray into this object. We compute this by simply taking\n\t      // the direction of the ray and making it as long as the distance\n\t      // returned by the intersection check.\n\t      var pointAtTime = _vector2.default.add(_vector2.default.mult(ray.direction, dist), ray.origin);\n\t\n\t      return this.surface(ray, scene, object, pointAtTime, object.calculateNormal(pointAtTime), depth);\n\t    }\n\t  }, {\n\t    key: 'intersectScene',\n\t    value: function intersectScene(ray, scene) {\n\t      return scene.objects.reduce(function (closest, object) {\n\t        var dist = object.calculateIntersection(ray);\n\t        return dist !== undefined && dist < closest[0] ? [dist, object] : closest;\n\t      }, [Infinity, null]);\n\t    }\n\t  }, {\n\t    key: 'surface',\n\t    value: function surface(ray, scene, object, pointAtTime, normal, depth) {\n\t      var color = _vector2.default.copy(_vector2.default.ZERO);\n\t      var lambertAmount = 0;\n\t\n\t      if (object.material.lambert) {\n\t        for (var i = 0; i < scene.lights.length; i++) {\n\t          var lightPoint = scene.lights[i];\n\t\n\t          // First: can we see the light? If not, this is a shadowy area\n\t          // and it gets no light from the lambert shading process.\n\t          if (!this.isLightVisible(pointAtTime, scene, lightPoint)) {\n\t            continue;\n\t          }\n\t          // Otherwise, calculate the lambertian reflectance, which\n\t          // essentially is a 'diffuse' lighting system - direct light\n\t          // is bright, and from there, less direct light is gradually,\n\t          // beautifully, less light.\n\t          var contribution = _vector2.default.dot(_vector2.default.normalize(_vector2.default.sub(lightPoint, pointAtTime)), normal);\n\t          // sometimes this formula can return negatives, so we check:\n\t          // we only want positive values for lighting.\n\t          if (contribution > 0) {\n\t            lambertAmount += contribution;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (object.material.specular) {\n\t        // This is basically the same thing as what we did in render(), just\n\t        // instead of looking from the viewpoint of the camera, we're looking\n\t        // from a point on the surface of a shiny object, seeing what it sees\n\t        // and making that part of a reflection.\n\t        var reflectedRay = { origin: pointAtTime, direction: _vector2.default.reflectThrough(ray.direction, normal) };\n\t        var reflectedColor = this.trace(reflectedRay, scene, depth + 1);\n\t        if (reflectedColor) {\n\t          color = _vector2.default.add(color, _vector2.default.mult(reflectedColor, object.material.specular));\n\t        }\n\t      }\n\t\n\t      // lambert should never 'blow out' the lighting of an object,\n\t      // even if the ray bounces between a lot of things and hits lights\n\t      lambertAmount = Math.min(1, lambertAmount);\n\t\n\t      // Ambient colors shine bright regardless of whether there's a light visible -\n\t      // a circle with a totally ambient blue color will always just be a flat blue\n\t      // circle.\n\t      color = _vector2.default.add(color, _vector2.default.mult(object.color, lambertAmount * object.material.lambert));\n\t      color = _vector2.default.add(color, _vector2.default.mult(object.color, object.material.ambient));\n\t      return color;\n\t    }\n\t  }, {\n\t    key: 'isLightVisible',\n\t    value: function isLightVisible(point, scene, light) {\n\t      var ray = { origin: point, direction: _vector2.default.normalize(_vector2.default.sub(point, light)) };\n\t\n\t      var _intersectScene3 = this.intersectScene(ray, scene),\n\t          _intersectScene4 = _slicedToArray(_intersectScene3, 1),\n\t          dist = _intersectScene4[0];\n\t\n\t      return dist > -0.005;\n\t    }\n\t  }, {\n\t    key: 'tick',\n\t    value: function tick() {\n\t      var scene = this.generateScene(this.time);\n\t      this.time++;\n\t\n\t      this.render(scene);\n\t\n\t      if (this.isPlaying) {\n\t        requestAnimationFrame(this.tick.bind(this));\n\t      }\n\t    }\n\t  }, {\n\t    key: 'play',\n\t    value: function play() {\n\t      if (this.isPlaying) {\n\t        return;\n\t      }\n\t      this.isPlaying = true;\n\t      requestAnimationFrame(this.tick.bind(this));\n\t    }\n\t  }, {\n\t    key: 'stop',\n\t    value: function stop() {\n\t      this.isPlaying = false;\n\t    }\n\t  }]);\n\t\n\t  return Renderer;\n\t}();\n\t\n\texports.default = Renderer;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t// # Vector Operations\n\t//\n\t// These are general-purpose functions that deal with vectors - in this case,\n\t// three-dimensional vectors represented as objects in the form\n\t//\n\t//     { x, y, z }\n\t//\n\t// Since we're not using traditional object oriented techniques, these\n\t// functions take and return that sort of logic-less object, so you'll see\n\t// `add(a, b)` rather than `a.add(b)`.\n\t//\n\t// Heavily cribbed from:\n\t//   https://github.com/processing/p5.js/blob/master/src/math/p5.Vector.js\n\t//   https://github.com/tmcw/literate-raytracer/blob/gh-pages/vector.js\n\t\n\tvar Vector = {};\n\t\n\t// # Constants\n\tVector.UP = { x: 0.0, y: 1.0, z: 0.0 };\n\tVector.ZERO = { x: 0.0, y: 0.0, z: 0.0 };\n\tVector.WHITE = { x: 255, y: 255, z: 255 };\n\t\n\tVector.new = function () {\n\t  var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t  var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\t\n\t  return { x: x, y: y, z: z };\n\t};\n\t\n\tVector.copy = function (a) {\n\t  return { x: a.x, y: a.y, z: a.z };\n\t};\n\t\n\tVector.dot = function (a, b) {\n\t  return a.x * b.x + a.y * b.y + a.z * b.z;\n\t};\n\t\n\tVector.cross = function (a, b) {\n\t  return {\n\t    x: a.y * b.z - a.z * b.y,\n\t    y: a.z * b.x - a.x * b.z,\n\t    z: a.x * b.y - a.y * b.x\n\t  };\n\t};\n\t\n\tVector.mult = function (a, t) {\n\t  return {\n\t    x: a.x * t,\n\t    y: a.y * t,\n\t    z: a.z * t\n\t  };\n\t};\n\t\n\tVector.div = function (a, t) {\n\t  return {\n\t    x: a.x / t,\n\t    y: a.y / t,\n\t    z: a.z / t\n\t  };\n\t};\n\t\n\tVector.normalize = function (a) {\n\t  var mag = Vector.mag(a);\n\t  return mag === 0 ? a : Vector.div(a, mag);\n\t};\n\t\n\t// Add two vectors to each other, by simply combining each\n\t// of their components\n\tVector.add = function (a, b) {\n\t  return {\n\t    x: a.x + b.x,\n\t    y: a.y + b.y,\n\t    z: a.z + b.z\n\t  };\n\t};\n\t\n\t// A version of `add` that adds three vectors at the same time. While\n\t// it's possible to write a clever version of `Vector.add` that takes\n\t// any number of arguments, it's not fast, so we're keeping it simple and\n\t// just making two versions.\n\tVector.add3 = function (a, b, c) {\n\t  return {\n\t    x: a.x + b.x + c.x,\n\t    y: a.y + b.y + c.y,\n\t    z: a.z + b.z + c.z\n\t  };\n\t};\n\t\n\t// Subtract one vector from another, by subtracting each component\n\tVector.sub = function (a, b) {\n\t  return {\n\t    x: a.x - b.x,\n\t    y: a.y - b.y,\n\t    z: a.z - b.z\n\t  };\n\t};\n\t\n\t// Length, or magnitude, measured by [Euclidean norm](https://en.wikipedia.org/wiki/Euclidean_vector#Length)\n\tVector.mag = function (a) {\n\t  return Math.sqrt(Vector.dot(a, a));\n\t};\n\t\n\tVector.angleBetween = function (a, b) {\n\t  return Math.acos(Vector.dot(a, b) / (Vector.mag(a) * Vector.mag(b))); // in radians\n\t};\n\t\n\t// Given a vector `a`, which is a point in space, and a `normal`, which is\n\t// the angle the point hits a surface, returna  new vector that is reflect\n\t// off of that surface\n\tVector.reflectThrough = function (a, normal) {\n\t  var d = Vector.mult(normal, Vector.dot(a, normal));\n\t  return Vector.sub(Vector.mult(d, 2), a);\n\t};\n\t\n\tVector.dist = function (a, b) {\n\t  var d = Vector.sub(b, a);\n\t  return Vector.mag(d);\n\t};\n\t\n\tVector.equal = function (a, b) {\n\t  return a.x === b.x && a.y === b.y && a.z === b.z;\n\t};\n\t\n\tVector.lerp = function (a, b, amount) {\n\t  return {\n\t    x: a.x + (b.x - a.x) * amount || 0,\n\t    y: a.y + (b.y - a.y) * amount || 0,\n\t    z: a.z + (b.z - a.z) * amount || 0\n\t  };\n\t};\n\t\n\tVector.setMag = function (a, n) {\n\t  return Vector.mult(Vector.normalize(a), n);\n\t};\n\t\n\tVector.limit = function (a, max) {\n\t  var magSq = Vector.dot(a, a);\n\t  if (magSq > max * max) {\n\t    return Vector.setMag(a, max);\n\t  } else {\n\t    return a;\n\t  }\n\t};\n\t\n\tVector.heading = function (a) {\n\t  return Math.atan2(a.y, a.x); // in radians\n\t};\n\t\n\tVector.rotate = function (a, angle) {\n\t  var newHeading = Vector.heading(a) + angle;\n\t  var mag = Vector.mag(a);\n\t  return {\n\t    x: Math.cos(newHeading) * mag,\n\t    y: Math.sin(newHeading) * mag,\n\t    z: a.z\n\t  };\n\t};\n\t\n\tVector.toString = function (a) {\n\t  return \"[\" + a.x + \", \" + a.y + \", \" + a.z + \"]\";\n\t};\n\t\n\tVector.toArray = function (a) {\n\t  return [a.x, a.y, a.z];\n\t};\n\t\n\texports.default = Vector;\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f47051289bb9596d8e6b","import Vector from './vector'\nimport { Sphere } from './objects'\nimport Renderer from './renderer'\n\nconst canvas = document.getElementById('canvas')\nconst width = 640 * 0.5\nconst height = 480 * 0.5\n\ncanvas.width = width\ncanvas.height = height\ncanvas.style.cssText = `width:${(width * 2)}px;height:${(height * 2)}px`\n\nfunction generateScene(progress) {\n  const scene = {\n    camera: {\n      point: Vector.new(0.0, 1.8, 10),\n      fieldOfView: 45,\n      direction: Vector.new(0.0, 3.0, 0.0)\n    },\n    lights: [Vector.new(-30, -10, 20)],\n    objects: [\n      new Sphere({\n        center: Vector.new(0, 3.5, -3),\n        radius: 3,\n        color: Vector.new(155, 200, 155),\n        material: {\n          specular: 0.2,\n          lambert: 0.7,\n          ambient: 0.1\n        }\n      }),\n      new Sphere({\n        center: Vector.new(Math.sin(progress * 0.1) * 3.5, 2, -3 + (Math.cos(progress * 0.1) * 3.5)),\n        radius: 0.2,\n        color: Vector.new(155, 155, 155),\n        material: {\n          specular: 0.1,\n          lambert: 0.9,\n          ambient: 0.0\n        }\n      }),\n      new Sphere({\n        center: Vector.new(Math.sin(progress * 0.2) * 4, 3, -3 + (Math.cos(progress * 0.2) * 4)),\n        radius: 0.1,\n        color: Vector.new(255, 255, 255),\n        material: {\n          specular: 0.2,\n          lambert: 0.7,\n          ambient: 0.1\n        }\n      })\n    ]\n  }\n\n  return scene\n}\n\nconst renderer = new Renderer(canvas, generateScene, { enableSampling: false })\n\nrenderer.tick()\n\ndocument.getElementById('play').onclick = renderer.play.bind(renderer)\ndocument.getElementById('stop').onclick = renderer.stop.bind(renderer)\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","// import VectorClass from './vector-class'\nimport VectorObjects from './vector-objects'\n\nexport default VectorObjects\n\n\n\n// WEBPACK FOOTER //\n// ./src/vector/index.js","export default class GeometricObject {\n  constructor(color, material) {\n    this.color = color\n    this.material = material\n  }\n\n  calculateIntersection() {\n    return undefined\n  }\n\n  calculateNormal() {\n    return undefined\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/objects/geometric-object.js","import Sphere from './sphere'\n\nexport {\n  Sphere\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/objects/index.js","import GeometricObject from './geometric-object'\nimport Vector from '../vector'\n\nexport default class Sphere extends GeometricObject {\n  constructor({ center, radius, color, material }) {\n    super(color, material)\n    this.center = center\n    this.radius = radius\n  }\n\n  calculateIntersection(ray) {\n    const eyeToCenter = Vector.sub(this.center, ray.origin)\n    const v = Vector.dot(eyeToCenter, ray.direction)\n    const eoDot = Vector.dot(eyeToCenter, eyeToCenter)\n    const discriminant = (this.radius * this.radius) - eoDot + (v * v)\n\n    if (discriminant < 0) {\n      return\n    }\n\n    return v - Math.sqrt(discriminant)\n  }\n\n  calculateNormal(pos) {\n    return Vector.normalize(Vector.sub(pos, this.center))\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/objects/sphere.js","import Vector from './vector'\n\nexport default class Renderer {\n  constructor(canvas, generateSceneCallback, { traceDepthLimit=3, enableSampling=false, numSamples=9 } = {}) {\n    const { width, height } = canvas\n\n    this.canvas = canvas\n    this.context = canvas.getContext('2d')\n    this.data = this.context.getImageData(0, 0, width, height)\n    this.generateScene = generateSceneCallback\n    this.traceDepthLimit = traceDepthLimit\n    this.enableSampling = enableSampling\n    this.numSamples = numSamples\n    this.isPlaying = false\n    this.time = 1\n  }\n\n  render(scene) {\n    const camera = scene.camera\n    const { width, height } = this.canvas\n    const data = this.data\n\n    // all the raytracing stuff goes here\n\n    const eyeVector = Vector.normalize(Vector.sub(camera.direction, camera.point)) // w (reversed?)\n    const vpRight = Vector.normalize(Vector.cross(eyeVector, Vector.UP)) // u\n    const vpUp = Vector.normalize(Vector.cross(vpRight, eyeVector)) // v\n\n    const fovRadians = Math.PI * (camera.fieldOfView / 2) / 180\n    const heightWidthRatio = height / width\n    const halfWidth = Math.tan(fovRadians)\n    const halfHeight = heightWidthRatio * halfWidth\n    const cameraWidth = halfWidth * 2\n    const cameraHeight = halfHeight * 2\n    const pixelWidth = cameraWidth / (width - 1)\n    const pixelHeight = cameraHeight / (height - 1)\n\n    const ray = { origin: camera.point, direction: Vector.new() }\n\n    for (let x = 0; x < width; x++) {\n      for (let y = 0; y < height; y++) {\n        let color = Vector.copy(Vector.ZERO)\n\n        if (this.enableSampling) {\n          const n = Math.sqrt(this.numSamples)\n\n          for (let p = 0; p < n; p++) {\n            for (let q = 0; q < n; q++) {\n              // turn the raw pixel x and y values into values from -1 to 1\n              // and use these values to scale the facing-right and facing-up\n              // vectors so that we generate versions of the `eyeVector` that are\n              // skewed in each necessary direction.\n              const xv = pixelWidth * (x - halfWidth + (q + Math.random()) / n) - halfWidth\n              const yv = pixelHeight * (y - halfHeight + (p + Math.random()) / n) - halfHeight\n              const xComp = Vector.mult(vpRight, xv)\n              const yComp = Vector.mult(vpUp, yv)\n\n              ray.direction = Vector.normalize(Vector.add3(xComp, yComp, eyeVector))\n\n              color = Vector.add(color, this.trace(ray, scene, 0))\n            }\n          }\n\n          color = Vector.div(color, this.numSamples)\n\n        } else {\n          const xv = pixelWidth * (x - halfWidth) - halfWidth\n          const yv = pixelHeight * (y - halfHeight) - halfHeight\n          const xComp = Vector.mult(vpRight, xv)\n          const yComp = Vector.mult(vpUp, yv)\n\n          ray.direction = Vector.normalize(Vector.add3(xComp, yComp, eyeVector))\n          color = this.trace(ray, scene, 0)\n        }\n\n        const index = (x * 4) + (y * width * 4)\n        data.data[index + 0] = color.x\n        data.data[index + 1] = color.y\n        data.data[index + 2] = color.z\n        data.data[index + 3] = 255\n      }\n    }\n\n    this.context.putImageData(data, 0, 0)\n  }\n\n  trace(ray, scene, depth) {\n    if (depth > this.traceDepthLimit) {\n      return\n    }\n\n    const [dist, object] = this.intersectScene(ray, scene)\n\n    if (dist === Infinity) {\n      return Vector.copy(Vector.WHITE)\n    }\n\n    // The pointAtTime is another way of saying the 'intersection point'\n    // of this ray into this object. We compute this by simply taking\n    // the direction of the ray and making it as long as the distance\n    // returned by the intersection check.\n    const pointAtTime = Vector.add(Vector.mult(ray.direction, dist), ray.origin)\n\n    return this.surface(ray, scene, object, pointAtTime, object.calculateNormal(pointAtTime), depth)\n  }\n\n  intersectScene(ray, scene) {\n    return scene.objects.reduce(function(closest, object) {\n      const dist = object.calculateIntersection(ray)\n      return dist !== undefined && dist < closest[0] ? [dist, object] : closest\n    }, [Infinity, null])\n  }\n\n  surface(ray, scene, object, pointAtTime, normal, depth) {\n    let color = Vector.copy(Vector.ZERO)\n    let lambertAmount = 0\n\n    if (object.material.lambert) {\n      for (let i = 0; i < scene.lights.length; i++) {\n        const lightPoint = scene.lights[i]\n\n        // First: can we see the light? If not, this is a shadowy area\n        // and it gets no light from the lambert shading process.\n        if (!this.isLightVisible(pointAtTime, scene, lightPoint)) {\n          continue\n        }\n        // Otherwise, calculate the lambertian reflectance, which\n        // essentially is a 'diffuse' lighting system - direct light\n        // is bright, and from there, less direct light is gradually,\n        // beautifully, less light.\n        const contribution = Vector.dot(Vector.normalize(Vector.sub(lightPoint, pointAtTime)), normal)\n        // sometimes this formula can return negatives, so we check:\n        // we only want positive values for lighting.\n        if (contribution > 0) {\n          lambertAmount += contribution\n        }\n      }\n    }\n\n    if (object.material.specular) {\n      // This is basically the same thing as what we did in render(), just\n      // instead of looking from the viewpoint of the camera, we're looking\n      // from a point on the surface of a shiny object, seeing what it sees\n      // and making that part of a reflection.\n      const reflectedRay = { origin: pointAtTime, direction: Vector.reflectThrough(ray.direction, normal) }\n      const reflectedColor = this.trace(reflectedRay, scene, depth + 1)\n      if (reflectedColor) {\n        color = Vector.add(color, Vector.mult(reflectedColor, object.material.specular))\n      }\n    }\n\n    // lambert should never 'blow out' the lighting of an object,\n    // even if the ray bounces between a lot of things and hits lights\n    lambertAmount = Math.min(1, lambertAmount)\n\n    // Ambient colors shine bright regardless of whether there's a light visible -\n    // a circle with a totally ambient blue color will always just be a flat blue\n    // circle.\n    color = Vector.add(color, Vector.mult(object.color, lambertAmount * object.material.lambert))\n    color = Vector.add(color, Vector.mult(object.color, object.material.ambient))\n    return color\n  }\n\n  isLightVisible(point, scene, light) {\n    const ray = { origin: point, direction: Vector.normalize(Vector.sub(point, light)) }\n    const [dist] = this.intersectScene(ray, scene)\n    return dist > -0.005\n  }\n\n  tick() {\n    const scene = this.generateScene(this.time)\n    this.time++\n\n    this.render(scene)\n\n    if (this.isPlaying) {\n      requestAnimationFrame(this.tick.bind(this))\n    }\n  }\n\n  play() {\n    if (this.isPlaying) {\n      return\n    }\n    this.isPlaying = true\n    requestAnimationFrame(this.tick.bind(this))\n  }\n\n  stop() {\n    this.isPlaying = false\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/renderer.js","// # Vector Operations\n//\n// These are general-purpose functions that deal with vectors - in this case,\n// three-dimensional vectors represented as objects in the form\n//\n//     { x, y, z }\n//\n// Since we're not using traditional object oriented techniques, these\n// functions take and return that sort of logic-less object, so you'll see\n// `add(a, b)` rather than `a.add(b)`.\n//\n// Heavily cribbed from:\n//   https://github.com/processing/p5.js/blob/master/src/math/p5.Vector.js\n//   https://github.com/tmcw/literate-raytracer/blob/gh-pages/vector.js\n\nconst Vector = {}\n\n// # Constants\nVector.UP = { x: 0.0, y: 1.0, z: 0.0 }\nVector.ZERO = { x: 0.0, y: 0.0, z: 0.0 }\nVector.WHITE = { x: 255, y: 255, z: 255 }\n\nVector.new = function(x = 0, y = 0, z = 0) {\n  return { x: x, y: y, z: z }\n}\n\nVector.copy = function(a) {\n  return { x: a.x, y: a.y, z: a.z }\n}\n\nVector.dot = function(a, b) {\n  return (a.x * b.x) + (a.y * b.y) + (a.z * b.z)\n}\n\nVector.cross = function(a, b) {\n  return {\n    x: (a.y * b.z) - (a.z * b.y),\n    y: (a.z * b.x) - (a.x * b.z),\n    z: (a.x * b.y) - (a.y * b.x)\n  }\n}\n\nVector.mult = function(a, t) {\n  return {\n    x: a.x * t,\n    y: a.y * t,\n    z: a.z * t\n  }\n}\n\nVector.div = function(a, t) {\n  return {\n    x: a.x / t,\n    y: a.y / t,\n    z: a.z / t\n  }\n}\n\nVector.normalize = function(a) {\n  const mag = Vector.mag(a)\n  return mag === 0 ? a : Vector.div(a, mag)\n}\n\n// Add two vectors to each other, by simply combining each\n// of their components\nVector.add = function(a, b) {\n  return {\n    x: a.x + b.x,\n    y: a.y + b.y,\n    z: a.z + b.z\n  }\n}\n\n// A version of `add` that adds three vectors at the same time. While\n// it's possible to write a clever version of `Vector.add` that takes\n// any number of arguments, it's not fast, so we're keeping it simple and\n// just making two versions.\nVector.add3 = function(a, b, c) {\n  return {\n    x: a.x + b.x + c.x,\n    y: a.y + b.y + c.y,\n    z: a.z + b.z + c.z\n  }\n}\n\n// Subtract one vector from another, by subtracting each component\nVector.sub = function(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y,\n    z: a.z - b.z\n  }\n}\n\n// Length, or magnitude, measured by [Euclidean norm](https://en.wikipedia.org/wiki/Euclidean_vector#Length)\nVector.mag = function(a) {\n  return Math.sqrt(Vector.dot(a, a))\n}\n\nVector.angleBetween = function(a, b) {\n  return Math.acos(Vector.dot(a, b) / (Vector.mag(a) * Vector.mag(b))) // in radians\n}\n\n// Given a vector `a`, which is a point in space, and a `normal`, which is\n// the angle the point hits a surface, returna  new vector that is reflect\n// off of that surface\nVector.reflectThrough = function(a, normal) {\n  const d = Vector.mult(normal, Vector.dot(a, normal))\n  return Vector.sub(Vector.mult(d, 2), a)\n}\n\nVector.dist = function(a, b) {\n  const d = Vector.sub(b, a)\n  return Vector.mag(d)\n}\n\nVector.equal = function(a, b) {\n  return a.x === b.x && a.y === b.y && a.z === b.z\n}\n\nVector.lerp = function(a, b, amount) {\n  return {\n    x: a.x + (b.x - a.x) * amount || 0,\n    y: a.y + (b.y - a.y) * amount || 0,\n    z: a.z + (b.z - a.z) * amount || 0\n  }\n}\n\nVector.setMag = function(a, n) {\n  return Vector.mult(Vector.normalize(a), n)\n}\n\nVector.limit = function(a, max) {\n  const magSq = Vector.dot(a, a)\n  if (magSq > max * max) {\n    return Vector.setMag(a, max)\n  } else {\n    return a\n  }\n}\n\nVector.heading = function(a) {\n  return Math.atan2(a.y, a.x) // in radians\n}\n\nVector.rotate = function(a, angle) {\n  const newHeading = Vector.heading(a) + angle\n  const mag = Vector.mag(a)\n  return {\n    x: Math.cos(newHeading) * mag,\n    y: Math.sin(newHeading) * mag,\n    z: a.z\n  }\n}\n\nVector.toString = function(a) {\n  return `[${a.x}, ${a.y}, ${a.z}]`\n}\n\nVector.toArray = function(a) {\n  return [a.x, a.y, a.z]\n}\n\nexport default Vector\n\n\n\n// WEBPACK FOOTER //\n// ./src/vector/vector-objects.js"],"sourceRoot":""}