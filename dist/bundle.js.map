{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap 76cb02641ae39f2e033e","webpack:///./src/index.js","webpack:///./src/objects/geometric-object.js","webpack:///./src/objects/index.js","webpack:///./src/objects/sphere.js","webpack:///./src/renderer.js","webpack:///./src/vector-objects.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","generateScene","progress","scene","camera","point","_vectorObjects2","new","fieldOfView","direction","lights","objects","_objects","Sphere","center","radius","color","material","specular","lambert","ambient","Math","sin","cos","_vectorObjects","_renderer","_renderer2","canvas","document","getElementById","width","height","style","cssText","renderer","tick","onclick","play","bind","stop","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","GeometricObject","this","undefined","_sphere","_sphere2","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","_geometricObject","_geometricObject2","_GeometricObject","_ref","_this","getPrototypeOf","ray","eyeToCenter","sub","origin","v","dot","eoDot","discriminant","sqrt","pos","normalize","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","push","err","Array","isArray","Renderer","generateSceneCallback","arguments","_ref$traceDepthLimit","traceDepthLimit","_ref$enableSampling","enableSampling","_ref$numSamples","numSamples","context","getContext","data","getImageData","isPlaying","time","_canvas","eyeVector","vpRight","cross","UP","vpUp","fovRadians","PI","heightWidthRatio","halfWidth","tan","halfHeight","cameraWidth","cameraHeight","pixelWidth","pixelHeight","x","y","copy","ZERO","n","q","xv","random","yv","xComp","mult","yComp","add3","add","trace","div","index","z","putImageData","depth","_intersectScene","intersectScene","_intersectScene2","dist","object","Infinity","WHITE","pointAtTime","surface","calculateNormal","reduce","closest","calculateIntersection","normal","lambertAmount","lightPoint","isLightVisible","contribution","reflectedRay","reflectThrough","reflectedColor","min","light","_intersectScene3","_intersectScene4","render","requestAnimationFrame","Vector","a","b","t","mag","angleBetween","acos","d","equal","lerp","amount","setMag","limit","max","magSq","heading","atan2","rotate","angle","newHeading","toString","toArray"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _vectorObjects = __webpack_require__(6);\n\t\n\tvar _vectorObjects2 = _interopRequireDefault(_vectorObjects);\n\t\n\tvar _objects = __webpack_require__(3);\n\t\n\tvar _renderer = __webpack_require__(5);\n\t\n\tvar _renderer2 = _interopRequireDefault(_renderer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar canvas = document.getElementById('canvas');\n\tvar width = 640 * 0.5;\n\tvar height = 480 * 0.5;\n\t\n\tcanvas.width = width;\n\tcanvas.height = height;\n\tcanvas.style.cssText = 'width:' + width * 2 + 'px;height:' + height * 2 + 'px';\n\t\n\tfunction generateScene(progress) {\n\t  var scene = {\n\t    camera: {\n\t      point: _vectorObjects2.default.new(0.0, 1.8, 10),\n\t      fieldOfView: 45,\n\t      direction: _vectorObjects2.default.new(0.0, 3.0, 0.0)\n\t    },\n\t    lights: [_vectorObjects2.default.new(-30, -10, 20)],\n\t    objects: [new _objects.Sphere({\n\t      center: _vectorObjects2.default.new(0, 3.5, -3),\n\t      radius: 3,\n\t      color: _vectorObjects2.default.new(155, 200, 155),\n\t      material: {\n\t        specular: 0.2,\n\t        lambert: 0.7,\n\t        ambient: 0.1\n\t      }\n\t    }), new _objects.Sphere({\n\t      center: _vectorObjects2.default.new(Math.sin(progress * 0.1) * 3.5, 2, -3 + Math.cos(progress * 0.1) * 3.5),\n\t      radius: 0.2,\n\t      color: _vectorObjects2.default.new(155, 155, 155),\n\t      material: {\n\t        specular: 0.1,\n\t        lambert: 0.9,\n\t        ambient: 0.0\n\t      }\n\t    }), new _objects.Sphere({\n\t      center: _vectorObjects2.default.new(Math.sin(progress * 0.2) * 4, 3, -3 + Math.cos(progress * 0.2) * 4),\n\t      radius: 0.1,\n\t      color: _vectorObjects2.default.new(255, 255, 255),\n\t      material: {\n\t        specular: 0.2,\n\t        lambert: 0.7,\n\t        ambient: 0.1\n\t      }\n\t    })]\n\t  };\n\t\n\t  return scene;\n\t}\n\t\n\tvar renderer = new _renderer2.default(canvas, generateScene);\n\t\n\trenderer.tick();\n\t\n\tdocument.getElementById('play').onclick = renderer.play.bind(renderer);\n\tdocument.getElementById('stop').onclick = renderer.stop.bind(renderer);\n\n/***/ },\n/* 1 */,\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar GeometricObject = function () {\n\t  function GeometricObject(color, material) {\n\t    _classCallCheck(this, GeometricObject);\n\t\n\t    this.color = color;\n\t    this.material = material;\n\t  }\n\t\n\t  _createClass(GeometricObject, [{\n\t    key: \"calculateIntersection\",\n\t    value: function calculateIntersection() {\n\t      return undefined;\n\t    }\n\t  }, {\n\t    key: \"calculateNormal\",\n\t    value: function calculateNormal() {\n\t      return undefined;\n\t    }\n\t  }]);\n\t\n\t  return GeometricObject;\n\t}();\n\t\n\texports.default = GeometricObject;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.Sphere = undefined;\n\t\n\tvar _sphere = __webpack_require__(4);\n\t\n\tvar _sphere2 = _interopRequireDefault(_sphere);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.Sphere = _sphere2.default;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _geometricObject = __webpack_require__(2);\n\t\n\tvar _geometricObject2 = _interopRequireDefault(_geometricObject);\n\t\n\tvar _vectorObjects = __webpack_require__(6);\n\t\n\tvar _vectorObjects2 = _interopRequireDefault(_vectorObjects);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar Sphere = function (_GeometricObject) {\n\t  _inherits(Sphere, _GeometricObject);\n\t\n\t  function Sphere(_ref) {\n\t    var center = _ref.center,\n\t        radius = _ref.radius,\n\t        color = _ref.color,\n\t        material = _ref.material;\n\t\n\t    _classCallCheck(this, Sphere);\n\t\n\t    var _this = _possibleConstructorReturn(this, (Sphere.__proto__ || Object.getPrototypeOf(Sphere)).call(this, color, material));\n\t\n\t    _this.center = center;\n\t    _this.radius = radius;\n\t    return _this;\n\t  }\n\t\n\t  _createClass(Sphere, [{\n\t    key: 'calculateIntersection',\n\t    value: function calculateIntersection(ray) {\n\t      var eyeToCenter = _vectorObjects2.default.sub(this.center, ray.origin);\n\t      var v = _vectorObjects2.default.dot(eyeToCenter, ray.direction);\n\t      var eoDot = _vectorObjects2.default.dot(eyeToCenter, eyeToCenter);\n\t      var discriminant = this.radius * this.radius - eoDot + v * v;\n\t\n\t      if (discriminant < 0) {\n\t        return;\n\t      }\n\t\n\t      return v - Math.sqrt(discriminant);\n\t    }\n\t  }, {\n\t    key: 'calculateNormal',\n\t    value: function calculateNormal(pos) {\n\t      return _vectorObjects2.default.normalize(_vectorObjects2.default.sub(pos, this.center));\n\t    }\n\t  }]);\n\t\n\t  return Sphere;\n\t}(_geometricObject2.default);\n\t\n\texports.default = Sphere;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _vectorObjects = __webpack_require__(6);\n\t\n\tvar _vectorObjects2 = _interopRequireDefault(_vectorObjects);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Renderer = function () {\n\t  function Renderer(canvas, generateSceneCallback) {\n\t    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n\t        _ref$traceDepthLimit = _ref.traceDepthLimit,\n\t        traceDepthLimit = _ref$traceDepthLimit === undefined ? 3 : _ref$traceDepthLimit,\n\t        _ref$enableSampling = _ref.enableSampling,\n\t        enableSampling = _ref$enableSampling === undefined ? false : _ref$enableSampling,\n\t        _ref$numSamples = _ref.numSamples,\n\t        numSamples = _ref$numSamples === undefined ? 9 : _ref$numSamples;\n\t\n\t    _classCallCheck(this, Renderer);\n\t\n\t    var width = canvas.width,\n\t        height = canvas.height;\n\t\n\t\n\t    this.canvas = canvas;\n\t    this.context = canvas.getContext('2d');\n\t    this.data = this.context.getImageData(0, 0, width, height);\n\t    this.generateScene = generateSceneCallback;\n\t    this.traceDepthLimit = traceDepthLimit;\n\t    this.enableSampling = enableSampling;\n\t    this.numSamples = numSamples;\n\t    this.isPlaying = false;\n\t    this.time = 1;\n\t  }\n\t\n\t  _createClass(Renderer, [{\n\t    key: 'render',\n\t    value: function render(scene) {\n\t      var camera = scene.camera;\n\t      var _canvas = this.canvas,\n\t          width = _canvas.width,\n\t          height = _canvas.height;\n\t\n\t      var data = this.data;\n\t\n\t      // all the raytracing stuff goes here\n\t\n\t      var eyeVector = _vectorObjects2.default.normalize(_vectorObjects2.default.sub(camera.direction, camera.point)); // w (reversed?)\n\t      var vpRight = _vectorObjects2.default.normalize(_vectorObjects2.default.cross(eyeVector, _vectorObjects2.default.UP)); // u\n\t      var vpUp = _vectorObjects2.default.normalize(_vectorObjects2.default.cross(vpRight, eyeVector)); // v\n\t\n\t      var fovRadians = Math.PI * (camera.fieldOfView / 2) / 180;\n\t      var heightWidthRatio = height / width;\n\t      var halfWidth = Math.tan(fovRadians);\n\t      var halfHeight = heightWidthRatio * halfWidth;\n\t      var cameraWidth = halfWidth * 2;\n\t      var cameraHeight = halfHeight * 2;\n\t      var pixelWidth = cameraWidth / (width - 1);\n\t      var pixelHeight = cameraHeight / (height - 1);\n\t\n\t      var ray = { origin: camera.point, direction: _vectorObjects2.default.new() };\n\t\n\t      for (var x = 0; x < width; x++) {\n\t        for (var y = 0; y < height; y++) {\n\t          var color = _vectorObjects2.default.copy(_vectorObjects2.default.ZERO);\n\t\n\t          if (this.enableSampling) {\n\t            var n = Math.sqrt(this.numSamples);\n\t\n\t            for (var p = 0; p < n; p++) {\n\t              for (var q = 0; q < n; q++) {\n\t                // turn the raw pixel x and y values into values from -1 to 1\n\t                // and use these values to scale the facing-right and facing-up\n\t                // vectors so that we generate versions of the `eyeVector` that are\n\t                // skewed in each necessary direction.\n\t                var xv = pixelWidth * (x - halfWidth + (q + Math.random()) / n) - halfWidth;\n\t                var yv = pixelHeight * (y - halfHeight + (p + Math.random()) / n) - halfHeight;\n\t                var xComp = _vectorObjects2.default.mult(vpRight, xv);\n\t                var yComp = _vectorObjects2.default.mult(vpUp, yv);\n\t\n\t                ray.direction = _vectorObjects2.default.normalize(_vectorObjects2.default.add3(xComp, yComp, eyeVector));\n\t\n\t                color = _vectorObjects2.default.add(color, this.trace(ray, scene, 0));\n\t              }\n\t            }\n\t\n\t            color = _vectorObjects2.default.div(color, this.numSamples);\n\t          } else {\n\t            var _xv = pixelWidth * (x - halfWidth) - halfWidth;\n\t            var _yv = pixelHeight * (y - halfHeight) - halfHeight;\n\t            var _xComp = _vectorObjects2.default.mult(vpRight, _xv);\n\t            var _yComp = _vectorObjects2.default.mult(vpUp, _yv);\n\t\n\t            ray.direction = _vectorObjects2.default.normalize(_vectorObjects2.default.add3(_xComp, _yComp, eyeVector));\n\t            color = this.trace(ray, scene, 0);\n\t          }\n\t\n\t          var index = x * 4 + y * width * 4;\n\t          data.data[index + 0] = color.x;\n\t          data.data[index + 1] = color.y;\n\t          data.data[index + 2] = color.z;\n\t          data.data[index + 3] = 255;\n\t        }\n\t      }\n\t\n\t      this.context.putImageData(data, 0, 0);\n\t    }\n\t  }, {\n\t    key: 'trace',\n\t    value: function trace(ray, scene, depth) {\n\t      if (depth > this.traceDepthLimit) {\n\t        return;\n\t      }\n\t\n\t      var _intersectScene = this.intersectScene(ray, scene),\n\t          _intersectScene2 = _slicedToArray(_intersectScene, 2),\n\t          dist = _intersectScene2[0],\n\t          object = _intersectScene2[1];\n\t\n\t      if (dist === Infinity) {\n\t        return _vectorObjects2.default.copy(_vectorObjects2.default.WHITE);\n\t      }\n\t\n\t      // The pointAtTime is another way of saying the 'intersection point'\n\t      // of this ray into this object. We compute this by simply taking\n\t      // the direction of the ray and making it as long as the distance\n\t      // returned by the intersection check.\n\t      var pointAtTime = _vectorObjects2.default.add(_vectorObjects2.default.mult(ray.direction, dist), ray.origin);\n\t\n\t      return this.surface(ray, scene, object, pointAtTime, object.calculateNormal(pointAtTime), depth);\n\t    }\n\t  }, {\n\t    key: 'intersectScene',\n\t    value: function intersectScene(ray, scene) {\n\t      return scene.objects.reduce(function (closest, object) {\n\t        var dist = object.calculateIntersection(ray);\n\t        return dist !== undefined && dist < closest[0] ? [dist, object] : closest;\n\t      }, [Infinity, null]);\n\t    }\n\t  }, {\n\t    key: 'surface',\n\t    value: function surface(ray, scene, object, pointAtTime, normal, depth) {\n\t      var color = _vectorObjects2.default.copy(_vectorObjects2.default.ZERO);\n\t      var lambertAmount = 0;\n\t\n\t      if (object.material.lambert) {\n\t        for (var i = 0; i < scene.lights.length; i++) {\n\t          var lightPoint = scene.lights[i];\n\t\n\t          // First: can we see the light? If not, this is a shadowy area\n\t          // and it gets no light from the lambert shading process.\n\t          if (!this.isLightVisible(pointAtTime, scene, lightPoint)) {\n\t            continue;\n\t          }\n\t          // Otherwise, calculate the lambertian reflectance, which\n\t          // essentially is a 'diffuse' lighting system - direct light\n\t          // is bright, and from there, less direct light is gradually,\n\t          // beautifully, less light.\n\t          var contribution = _vectorObjects2.default.dot(_vectorObjects2.default.normalize(_vectorObjects2.default.sub(lightPoint, pointAtTime)), normal);\n\t          // sometimes this formula can return negatives, so we check:\n\t          // we only want positive values for lighting.\n\t          if (contribution > 0) {\n\t            lambertAmount += contribution;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (object.material.specular) {\n\t        // This is basically the same thing as what we did in render(), just\n\t        // instead of looking from the viewpoint of the camera, we're looking\n\t        // from a point on the surface of a shiny object, seeing what it sees\n\t        // and making that part of a reflection.\n\t        var reflectedRay = { origin: pointAtTime, direction: _vectorObjects2.default.reflectThrough(ray.direction, normal) };\n\t        var reflectedColor = this.trace(reflectedRay, scene, depth + 1);\n\t        if (reflectedColor) {\n\t          color = _vectorObjects2.default.add(color, _vectorObjects2.default.mult(reflectedColor, object.material.specular));\n\t        }\n\t      }\n\t\n\t      // lambert should never 'blow out' the lighting of an object,\n\t      // even if the ray bounces between a lot of things and hits lights\n\t      lambertAmount = Math.min(1, lambertAmount);\n\t\n\t      // Ambient colors shine bright regardless of whether there's a light visible -\n\t      // a circle with a totally ambient blue color will always just be a flat blue\n\t      // circle.\n\t      color = _vectorObjects2.default.add(color, _vectorObjects2.default.mult(object.color, lambertAmount * object.material.lambert));\n\t      color = _vectorObjects2.default.add(color, _vectorObjects2.default.mult(object.color, object.material.ambient));\n\t      return color;\n\t    }\n\t  }, {\n\t    key: 'isLightVisible',\n\t    value: function isLightVisible(point, scene, light) {\n\t      var ray = { origin: point, direction: _vectorObjects2.default.normalize(_vectorObjects2.default.sub(point, light)) };\n\t\n\t      var _intersectScene3 = this.intersectScene(ray, scene),\n\t          _intersectScene4 = _slicedToArray(_intersectScene3, 1),\n\t          dist = _intersectScene4[0];\n\t\n\t      return dist > -0.005;\n\t    }\n\t  }, {\n\t    key: 'tick',\n\t    value: function tick() {\n\t      var scene = this.generateScene(this.time);\n\t      this.time++;\n\t\n\t      this.render(scene);\n\t\n\t      if (this.isPlaying) {\n\t        requestAnimationFrame(this.tick.bind(this));\n\t      }\n\t    }\n\t  }, {\n\t    key: 'play',\n\t    value: function play() {\n\t      if (this.isPlaying) {\n\t        return;\n\t      }\n\t      this.isPlaying = true;\n\t      requestAnimationFrame(this.tick.bind(this));\n\t    }\n\t  }, {\n\t    key: 'stop',\n\t    value: function stop() {\n\t      this.isPlaying = false;\n\t    }\n\t  }]);\n\t\n\t  return Renderer;\n\t}();\n\t\n\texports.default = Renderer;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t// # Vector Operations\n\t//\n\t// These are general-purpose functions that deal with vectors - in this case,\n\t// three-dimensional vectors represented as objects in the form\n\t//\n\t//     { x, y, z }\n\t//\n\t// Since we're not using traditional object oriented techniques, these\n\t// functions take and return that sort of logic-less object, so you'll see\n\t// `add(a, b)` rather than `a.add(b)`.\n\t//\n\t// Heavily cribbed from:\n\t//   https://github.com/processing/p5.js/blob/master/src/math/p5.Vector.js\n\t//   https://github.com/tmcw/literate-raytracer/blob/gh-pages/vector.js\n\t\n\tvar Vector = {};\n\t\n\t// # Constants\n\tVector.UP = { x: 0.0, y: 1.0, z: 0.0 };\n\tVector.ZERO = { x: 0.0, y: 0.0, z: 0.0 };\n\tVector.WHITE = { x: 255, y: 255, z: 255 };\n\t\n\tVector.new = function () {\n\t  var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t  var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\t\n\t  return { x: x, y: y, z: z };\n\t};\n\t\n\tVector.copy = function (a) {\n\t  return { x: a.x, y: a.y, z: a.z };\n\t};\n\t\n\tVector.dot = function (a, b) {\n\t  return a.x * b.x + a.y * b.y + a.z * b.z;\n\t};\n\t\n\tVector.cross = function (a, b) {\n\t  return {\n\t    x: a.y * b.z - a.z * b.y,\n\t    y: a.z * b.x - a.x * b.z,\n\t    z: a.x * b.y - a.y * b.x\n\t  };\n\t};\n\t\n\tVector.mult = function (a, t) {\n\t  return {\n\t    x: a.x * t,\n\t    y: a.y * t,\n\t    z: a.z * t\n\t  };\n\t};\n\t\n\tVector.div = function (a, t) {\n\t  return {\n\t    x: a.x / t,\n\t    y: a.y / t,\n\t    z: a.z / t\n\t  };\n\t};\n\t\n\tVector.normalize = function (a) {\n\t  var mag = Vector.mag(a);\n\t  return mag === 0 ? a : Vector.div(a, mag);\n\t};\n\t\n\t// Add two vectors to each other, by simply combining each\n\t// of their components\n\tVector.add = function (a, b) {\n\t  return {\n\t    x: a.x + b.x,\n\t    y: a.y + b.y,\n\t    z: a.z + b.z\n\t  };\n\t};\n\t\n\t// A version of `add` that adds three vectors at the same time. While\n\t// it's possible to write a clever version of `Vector.add` that takes\n\t// any number of arguments, it's not fast, so we're keeping it simple and\n\t// just making two versions.\n\tVector.add3 = function (a, b, c) {\n\t  return {\n\t    x: a.x + b.x + c.x,\n\t    y: a.y + b.y + c.y,\n\t    z: a.z + b.z + c.z\n\t  };\n\t};\n\t\n\t// Subtract one vector from another, by subtracting each component\n\tVector.sub = function (a, b) {\n\t  return {\n\t    x: a.x - b.x,\n\t    y: a.y - b.y,\n\t    z: a.z - b.z\n\t  };\n\t};\n\t\n\t// Length, or magnitude, measured by [Euclidean norm](https://en.wikipedia.org/wiki/Euclidean_vector#Length)\n\tVector.mag = function (a) {\n\t  return Math.sqrt(Vector.dot(a, a));\n\t};\n\t\n\tVector.angleBetween = function (a, b) {\n\t  return Math.acos(Vector.dot(a, b) / (Vector.mag(a) * Vector.mag(b))); // in radians\n\t};\n\t\n\t// Given a vector `a`, which is a point in space, and a `normal`, which is\n\t// the angle the point hits a surface, returna  new vector that is reflect\n\t// off of that surface\n\tVector.reflectThrough = function (a, normal) {\n\t  var d = Vector.mult(normal, Vector.dot(a, normal));\n\t  return Vector.sub(Vector.mult(d, 2), a);\n\t};\n\t\n\tVector.dist = function (a, b) {\n\t  var d = Vector.sub(b, a);\n\t  return Vector.mag(d);\n\t};\n\t\n\tVector.equal = function (a, b) {\n\t  return a.x === b.x && a.y === b.y && a.z === b.z;\n\t};\n\t\n\tVector.lerp = function (a, b, amount) {\n\t  return {\n\t    x: a.x + (b.x - a.x) * amount || 0,\n\t    y: a.y + (b.y - a.y) * amount || 0,\n\t    z: a.z + (b.z - a.z) * amount || 0\n\t  };\n\t};\n\t\n\tVector.setMag = function (a, n) {\n\t  return Vector.mult(Vector.normalize(a), n);\n\t};\n\t\n\tVector.limit = function (a, max) {\n\t  var magSq = Vector.dot(a, a);\n\t  if (magSq > max * max) {\n\t    return Vector.setMag(a, max);\n\t  } else {\n\t    return a;\n\t  }\n\t};\n\t\n\tVector.heading = function (a) {\n\t  return Math.atan2(a.y, a.x); // in radians\n\t};\n\t\n\tVector.rotate = function (a, angle) {\n\t  var newHeading = Vector.heading(a) + angle;\n\t  var mag = Vector.mag(a);\n\t  return {\n\t    x: Math.cos(newHeading) * mag,\n\t    y: Math.sin(newHeading) * mag,\n\t    z: a.z\n\t  };\n\t};\n\t\n\tVector.toString = function (a) {\n\t  return \"[\" + a.x + \", \" + a.y + \", \" + a.z + \"]\";\n\t};\n\t\n\tVector.toArray = function (a) {\n\t  return [a.x, a.y, a.z];\n\t};\n\t\n\texports.default = Vector;\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 76cb02641ae39f2e033e","import Vector from './vector-objects'\nimport { Sphere } from './objects'\nimport Renderer from './renderer'\n\nconst canvas = document.getElementById('canvas')\nconst width = 640 * 0.5\nconst height = 480 * 0.5\n\ncanvas.width = width\ncanvas.height = height\ncanvas.style.cssText = `width:${(width * 2)}px;height:${(height * 2)}px`\n\nfunction generateScene(progress) {\n  const scene = {\n    camera: {\n      point: Vector.new(0.0, 1.8, 10),\n      fieldOfView: 45,\n      direction: Vector.new(0.0, 3.0, 0.0)\n    },\n    lights: [Vector.new(-30, -10, 20)],\n    objects: [\n      new Sphere({\n        center: Vector.new(0, 3.5, -3),\n        radius: 3,\n        color: Vector.new(155, 200, 155),\n        material: {\n          specular: 0.2,\n          lambert: 0.7,\n          ambient: 0.1\n        }\n      }),\n      new Sphere({\n        center: Vector.new(Math.sin(progress * 0.1) * 3.5, 2, -3 + (Math.cos(progress * 0.1) * 3.5)),\n        radius: 0.2,\n        color: Vector.new(155, 155, 155),\n        material: {\n          specular: 0.1,\n          lambert: 0.9,\n          ambient: 0.0\n        }\n      }),\n      new Sphere({\n        center: Vector.new(Math.sin(progress * 0.2) * 4, 3, -3 + (Math.cos(progress * 0.2) * 4)),\n        radius: 0.1,\n        color: Vector.new(255, 255, 255),\n        material: {\n          specular: 0.2,\n          lambert: 0.7,\n          ambient: 0.1\n        }\n      })\n    ]\n  }\n\n  return scene\n}\n\nconst renderer = new Renderer(canvas, generateScene)\n\nrenderer.tick()\n\ndocument.getElementById('play').onclick = renderer.play.bind(renderer)\ndocument.getElementById('stop').onclick = renderer.stop.bind(renderer)\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","export default class GeometricObject {\n  constructor(color, material) {\n    this.color = color\n    this.material = material\n  }\n\n  calculateIntersection() {\n    return undefined\n  }\n\n  calculateNormal() {\n    return undefined\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/objects/geometric-object.js","import Sphere from './sphere'\n\nexport {\n  Sphere\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/objects/index.js","import GeometricObject from './geometric-object'\nimport Vector from '../vector-objects'\n\nexport default class Sphere extends GeometricObject {\n  constructor({ center, radius, color, material }) {\n    super(color, material)\n    this.center = center\n    this.radius = radius\n  }\n\n  calculateIntersection(ray) {\n    const eyeToCenter = Vector.sub(this.center, ray.origin)\n    const v = Vector.dot(eyeToCenter, ray.direction)\n    const eoDot = Vector.dot(eyeToCenter, eyeToCenter)\n    const discriminant = (this.radius * this.radius) - eoDot + (v * v)\n\n    if (discriminant < 0) {\n      return\n    }\n\n    return v - Math.sqrt(discriminant)\n  }\n\n  calculateNormal(pos) {\n    return Vector.normalize(Vector.sub(pos, this.center))\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/objects/sphere.js","import Vector from './vector-objects'\n\nexport default class Renderer {\n  constructor(canvas, generateSceneCallback, { traceDepthLimit=3, enableSampling=false, numSamples=9 } = {}) {\n    const { width, height } = canvas\n\n    this.canvas = canvas\n    this.context = canvas.getContext('2d')\n    this.data = this.context.getImageData(0, 0, width, height)\n    this.generateScene = generateSceneCallback\n    this.traceDepthLimit = traceDepthLimit\n    this.enableSampling = enableSampling\n    this.numSamples = numSamples\n    this.isPlaying = false\n    this.time = 1\n  }\n\n  render(scene) {\n    const camera = scene.camera\n    const { width, height } = this.canvas\n    const data = this.data\n\n    // all the raytracing stuff goes here\n\n    const eyeVector = Vector.normalize(Vector.sub(camera.direction, camera.point)) // w (reversed?)\n    const vpRight = Vector.normalize(Vector.cross(eyeVector, Vector.UP)) // u\n    const vpUp = Vector.normalize(Vector.cross(vpRight, eyeVector)) // v\n\n    const fovRadians = Math.PI * (camera.fieldOfView / 2) / 180\n    const heightWidthRatio = height / width\n    const halfWidth = Math.tan(fovRadians)\n    const halfHeight = heightWidthRatio * halfWidth\n    const cameraWidth = halfWidth * 2\n    const cameraHeight = halfHeight * 2\n    const pixelWidth = cameraWidth / (width - 1)\n    const pixelHeight = cameraHeight / (height - 1)\n\n    const ray = { origin: camera.point, direction: Vector.new() }\n\n    for (let x = 0; x < width; x++) {\n      for (let y = 0; y < height; y++) {\n        let color = Vector.copy(Vector.ZERO)\n\n        if (this.enableSampling) {\n          const n = Math.sqrt(this.numSamples)\n\n          for (let p = 0; p < n; p++) {\n            for (let q = 0; q < n; q++) {\n              // turn the raw pixel x and y values into values from -1 to 1\n              // and use these values to scale the facing-right and facing-up\n              // vectors so that we generate versions of the `eyeVector` that are\n              // skewed in each necessary direction.\n              const xv = pixelWidth * (x - halfWidth + (q + Math.random()) / n) - halfWidth\n              const yv = pixelHeight * (y - halfHeight + (p + Math.random()) / n) - halfHeight\n              const xComp = Vector.mult(vpRight, xv)\n              const yComp = Vector.mult(vpUp, yv)\n\n              ray.direction = Vector.normalize(Vector.add3(xComp, yComp, eyeVector))\n\n              color = Vector.add(color, this.trace(ray, scene, 0))\n            }\n          }\n\n          color = Vector.div(color, this.numSamples)\n\n        } else {\n          const xv = pixelWidth * (x - halfWidth) - halfWidth\n          const yv = pixelHeight * (y - halfHeight) - halfHeight\n          const xComp = Vector.mult(vpRight, xv)\n          const yComp = Vector.mult(vpUp, yv)\n\n          ray.direction = Vector.normalize(Vector.add3(xComp, yComp, eyeVector))\n          color = this.trace(ray, scene, 0)\n        }\n\n        const index = (x * 4) + (y * width * 4)\n        data.data[index + 0] = color.x\n        data.data[index + 1] = color.y\n        data.data[index + 2] = color.z\n        data.data[index + 3] = 255\n      }\n    }\n\n    this.context.putImageData(data, 0, 0)\n  }\n\n  trace(ray, scene, depth) {\n    if (depth > this.traceDepthLimit) {\n      return\n    }\n\n    const [dist, object] = this.intersectScene(ray, scene)\n\n    if (dist === Infinity) {\n      return Vector.copy(Vector.WHITE)\n    }\n\n    // The pointAtTime is another way of saying the 'intersection point'\n    // of this ray into this object. We compute this by simply taking\n    // the direction of the ray and making it as long as the distance\n    // returned by the intersection check.\n    const pointAtTime = Vector.add(Vector.mult(ray.direction, dist), ray.origin)\n\n    return this.surface(ray, scene, object, pointAtTime, object.calculateNormal(pointAtTime), depth)\n  }\n\n  intersectScene(ray, scene) {\n    return scene.objects.reduce(function(closest, object) {\n      const dist = object.calculateIntersection(ray)\n      return dist !== undefined && dist < closest[0] ? [dist, object] : closest\n    }, [Infinity, null])\n  }\n\n  surface(ray, scene, object, pointAtTime, normal, depth) {\n    let color = Vector.copy(Vector.ZERO)\n    let lambertAmount = 0\n\n    if (object.material.lambert) {\n      for (let i = 0; i < scene.lights.length; i++) {\n        const lightPoint = scene.lights[i]\n\n        // First: can we see the light? If not, this is a shadowy area\n        // and it gets no light from the lambert shading process.\n        if (!this.isLightVisible(pointAtTime, scene, lightPoint)) {\n          continue\n        }\n        // Otherwise, calculate the lambertian reflectance, which\n        // essentially is a 'diffuse' lighting system - direct light\n        // is bright, and from there, less direct light is gradually,\n        // beautifully, less light.\n        const contribution = Vector.dot(Vector.normalize(Vector.sub(lightPoint, pointAtTime)), normal)\n        // sometimes this formula can return negatives, so we check:\n        // we only want positive values for lighting.\n        if (contribution > 0) {\n          lambertAmount += contribution\n        }\n      }\n    }\n\n    if (object.material.specular) {\n      // This is basically the same thing as what we did in render(), just\n      // instead of looking from the viewpoint of the camera, we're looking\n      // from a point on the surface of a shiny object, seeing what it sees\n      // and making that part of a reflection.\n      const reflectedRay = { origin: pointAtTime, direction: Vector.reflectThrough(ray.direction, normal) }\n      const reflectedColor = this.trace(reflectedRay, scene, depth + 1)\n      if (reflectedColor) {\n        color = Vector.add(color, Vector.mult(reflectedColor, object.material.specular))\n      }\n    }\n\n    // lambert should never 'blow out' the lighting of an object,\n    // even if the ray bounces between a lot of things and hits lights\n    lambertAmount = Math.min(1, lambertAmount)\n\n    // Ambient colors shine bright regardless of whether there's a light visible -\n    // a circle with a totally ambient blue color will always just be a flat blue\n    // circle.\n    color = Vector.add(color, Vector.mult(object.color, lambertAmount * object.material.lambert))\n    color = Vector.add(color, Vector.mult(object.color, object.material.ambient))\n    return color\n  }\n\n  isLightVisible(point, scene, light) {\n    const ray = { origin: point, direction: Vector.normalize(Vector.sub(point, light)) }\n    const [dist] = this.intersectScene(ray, scene)\n    return dist > -0.005\n  }\n\n  tick() {\n    const scene = this.generateScene(this.time)\n    this.time++\n\n    this.render(scene)\n\n    if (this.isPlaying) {\n      requestAnimationFrame(this.tick.bind(this))\n    }\n  }\n\n  play() {\n    if (this.isPlaying) {\n      return\n    }\n    this.isPlaying = true\n    requestAnimationFrame(this.tick.bind(this))\n  }\n\n  stop() {\n    this.isPlaying = false\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/renderer.js","// # Vector Operations\n//\n// These are general-purpose functions that deal with vectors - in this case,\n// three-dimensional vectors represented as objects in the form\n//\n//     { x, y, z }\n//\n// Since we're not using traditional object oriented techniques, these\n// functions take and return that sort of logic-less object, so you'll see\n// `add(a, b)` rather than `a.add(b)`.\n//\n// Heavily cribbed from:\n//   https://github.com/processing/p5.js/blob/master/src/math/p5.Vector.js\n//   https://github.com/tmcw/literate-raytracer/blob/gh-pages/vector.js\n\nconst Vector = {}\n\n// # Constants\nVector.UP = { x: 0.0, y: 1.0, z: 0.0 }\nVector.ZERO = { x: 0.0, y: 0.0, z: 0.0 }\nVector.WHITE = { x: 255, y: 255, z: 255 }\n\nVector.new = function(x = 0, y = 0, z = 0) {\n  return { x: x, y: y, z: z }\n}\n\nVector.copy = function(a) {\n  return { x: a.x, y: a.y, z: a.z }\n}\n\nVector.dot = function(a, b) {\n  return (a.x * b.x) + (a.y * b.y) + (a.z * b.z)\n}\n\nVector.cross = function(a, b) {\n  return {\n    x: (a.y * b.z) - (a.z * b.y),\n    y: (a.z * b.x) - (a.x * b.z),\n    z: (a.x * b.y) - (a.y * b.x)\n  }\n}\n\nVector.mult = function(a, t) {\n  return {\n    x: a.x * t,\n    y: a.y * t,\n    z: a.z * t\n  }\n}\n\nVector.div = function(a, t) {\n  return {\n    x: a.x / t,\n    y: a.y / t,\n    z: a.z / t\n  }\n}\n\nVector.normalize = function(a) {\n  const mag = Vector.mag(a)\n  return mag === 0 ? a : Vector.div(a, mag)\n}\n\n// Add two vectors to each other, by simply combining each\n// of their components\nVector.add = function(a, b) {\n  return {\n    x: a.x + b.x,\n    y: a.y + b.y,\n    z: a.z + b.z\n  }\n}\n\n// A version of `add` that adds three vectors at the same time. While\n// it's possible to write a clever version of `Vector.add` that takes\n// any number of arguments, it's not fast, so we're keeping it simple and\n// just making two versions.\nVector.add3 = function(a, b, c) {\n  return {\n    x: a.x + b.x + c.x,\n    y: a.y + b.y + c.y,\n    z: a.z + b.z + c.z\n  }\n}\n\n// Subtract one vector from another, by subtracting each component\nVector.sub = function(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y,\n    z: a.z - b.z\n  }\n}\n\n// Length, or magnitude, measured by [Euclidean norm](https://en.wikipedia.org/wiki/Euclidean_vector#Length)\nVector.mag = function(a) {\n  return Math.sqrt(Vector.dot(a, a))\n}\n\nVector.angleBetween = function(a, b) {\n  return Math.acos(Vector.dot(a, b) / (Vector.mag(a) * Vector.mag(b))) // in radians\n}\n\n// Given a vector `a`, which is a point in space, and a `normal`, which is\n// the angle the point hits a surface, returna  new vector that is reflect\n// off of that surface\nVector.reflectThrough = function(a, normal) {\n  const d = Vector.mult(normal, Vector.dot(a, normal))\n  return Vector.sub(Vector.mult(d, 2), a)\n}\n\nVector.dist = function(a, b) {\n  const d = Vector.sub(b, a)\n  return Vector.mag(d)\n}\n\nVector.equal = function(a, b) {\n  return a.x === b.x && a.y === b.y && a.z === b.z\n}\n\nVector.lerp = function(a, b, amount) {\n  return {\n    x: a.x + (b.x - a.x) * amount || 0,\n    y: a.y + (b.y - a.y) * amount || 0,\n    z: a.z + (b.z - a.z) * amount || 0\n  }\n}\n\nVector.setMag = function(a, n) {\n  return Vector.mult(Vector.normalize(a), n)\n}\n\nVector.limit = function(a, max) {\n  const magSq = Vector.dot(a, a)\n  if (magSq > max * max) {\n    return Vector.setMag(a, max)\n  } else {\n    return a\n  }\n}\n\nVector.heading = function(a) {\n  return Math.atan2(a.y, a.x) // in radians\n}\n\nVector.rotate = function(a, angle) {\n  const newHeading = Vector.heading(a) + angle\n  const mag = Vector.mag(a)\n  return {\n    x: Math.cos(newHeading) * mag,\n    y: Math.sin(newHeading) * mag,\n    z: a.z\n  }\n}\n\nVector.toString = function(a) {\n  return `[${a.x}, ${a.y}, ${a.z}]`\n}\n\nVector.toArray = function(a) {\n  return [a.x, a.y, a.z]\n}\n\nexport default Vector\n\n\n\n// WEBPACK FOOTER //\n// ./src/vector-objects.js"],"sourceRoot":""}