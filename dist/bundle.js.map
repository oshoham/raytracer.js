{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap 44d048cd5887b5c77176","webpack:///./src/index.js","webpack:///./src/vector/index.js","webpack:///./src/objects/index.js","webpack:///./src/objects/sphere.js","webpack:///./src/renderer.js","webpack:///./src/vector/vector-objects.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","generateScene","progress","scene","camera","point","x","y","z","fieldOfView","direction","lights","objects","type","center","radius","color","material","specular","lambert","ambient","Math","sin","cos","_vector","_renderer","_renderer2","canvas","document","getElementById","width","height","style","cssText","renderer","enableSampling","tick","onclick","play","bind","stop","Object","defineProperty","value","_vectorObjects","_vectorObjects2","calculateIntersection","object","ray","Error","_sphere","sphereIntersection","calculateNormal","pos","sphereNormal","undefined","sphere","eyeToCenter","_vector2","sub","origin","v","dot","eoDot","discriminant","sqrt","normalize","_classCallCheck","instance","Constructor","TypeError","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","push","length","err","Array","isArray","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","_objects","Renderer","generateSceneCallback","_ref","arguments","_ref$traceDepthLimit","traceDepthLimit","_ref$enableSampling","_ref$numSamples","numSamples","this","context","getContext","data","getImageData","isPlaying","time","_canvas","eyeVector","vpRight","cross","UP","vpUp","fovRadians","PI","heightWidthRatio","halfWidth","tan","halfHeight","cameraWidth","cameraHeight","pixelWidth","pixelHeight","new","copy","ZERO","n","q","xv","random","yv","xComp","mult","yComp","add3","add","trace","div","index","putImageData","depth","_intersectScene","intersectScene","_intersectScene2","dist","Infinity","WHITE","pointAtTime","surface","reduce","closest","normal","lambertAmount","lightPoint","isLightVisible","contribution","reflectedRay","reflectThrough","reflectedColor","min","light","_intersectScene3","_intersectScene4","render","requestAnimationFrame","Vector","a","b","t","mag","angleBetween","acos","d","equal","lerp","amount","setMag","limit","max","magSq","heading","atan2","rotate","angle","newHeading","toString","toArray"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _vector = __webpack_require__(1);\n\t\n\tvar _vector2 = _interopRequireDefault(_vector);\n\t\n\tvar _renderer = __webpack_require__(4);\n\t\n\tvar _renderer2 = _interopRequireDefault(_renderer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar canvas = document.getElementById('canvas');\n\tvar width = 640 * 0.5;\n\tvar height = 480 * 0.5;\n\t\n\tcanvas.width = width;\n\tcanvas.height = height;\n\tcanvas.style.cssText = 'width:' + width * 2 + 'px;height:' + height * 2 + 'px';\n\t\n\tfunction generateScene(progress) {\n\t  var scene = {\n\t    camera: {\n\t      point: { x: 0.0, y: 1.8, z: 10 },\n\t      fieldOfView: 45,\n\t      direction: { x: 0.0, y: 3.0, z: 0.0 }\n\t    },\n\t    lights: [{ x: -30, y: -10, z: 20 }],\n\t    objects: [{\n\t      type: 'sphere',\n\t      center: { x: 0, y: 3.5, z: -3 },\n\t      radius: 3,\n\t      color: { x: 155, y: 200, z: 155 },\n\t      material: {\n\t        specular: 0.2,\n\t        lambert: 0.7,\n\t        ambient: 0.1\n\t      }\n\t    }, {\n\t      type: 'sphere',\n\t      center: {\n\t        x: Math.sin(progress * 0.1) * 3.5,\n\t        y: 2,\n\t        z: -3 + Math.cos(progress * 0.1) * 3.5\n\t      },\n\t      radius: 0.2,\n\t      color: { x: 155, y: 155, z: 155 },\n\t      material: {\n\t        specular: 0.1,\n\t        lambert: 0.9,\n\t        ambient: 0.0\n\t      }\n\t    }, {\n\t      type: 'sphere',\n\t      center: {\n\t        x: Math.sin(progress * 0.2) * 4,\n\t        y: 3,\n\t        z: -3 + Math.cos(progress * 0.2) * 4\n\t      },\n\t      radius: 0.1,\n\t      color: { x: 255, y: 255, z: 255 },\n\t      material: {\n\t        specular: 0.2,\n\t        lambert: 0.7,\n\t        ambient: 0.1\n\t      }\n\t    }]\n\t  };\n\t\n\t  return scene;\n\t}\n\t\n\tvar renderer = new _renderer2.default(canvas, generateScene, { enableSampling: false });\n\t\n\trenderer.tick();\n\t\n\tdocument.getElementById('play').onclick = renderer.play.bind(renderer);\n\tdocument.getElementById('stop').onclick = renderer.stop.bind(renderer);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _vectorObjects = __webpack_require__(5);\n\t\n\tvar _vectorObjects2 = _interopRequireDefault(_vectorObjects);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = _vectorObjects2.default; // import VectorClass from './vector-class'\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.calculateNormal = exports.calculateIntersection = undefined;\n\t\n\tvar _sphere = __webpack_require__(3);\n\t\n\tfunction calculateIntersection(object, ray) {\n\t  if (!object.type) {\n\t    throw new Error('Object has no type.');\n\t  }\n\t\n\t  switch (object.type) {\n\t    case 'sphere':\n\t      return (0, _sphere.sphereIntersection)(object, ray);\n\t    default:\n\t      throw new Error('Invalid object type.');\n\t  }\n\t}\n\t\n\tfunction calculateNormal(object, pos) {\n\t  if (!object.type) {\n\t    throw new Error('Object has no type.');\n\t  }\n\t\n\t  switch (object.type) {\n\t    case 'sphere':\n\t      return (0, _sphere.sphereNormal)(object, pos);\n\t    default:\n\t      throw new Error('Invalid object type.');\n\t  }\n\t}\n\t\n\texports.calculateIntersection = calculateIntersection;\n\texports.calculateNormal = calculateNormal;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.sphereNormal = exports.sphereIntersection = undefined;\n\t\n\tvar _vector = __webpack_require__(1);\n\t\n\tvar _vector2 = _interopRequireDefault(_vector);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction sphereIntersection(sphere, ray) {\n\t  var eyeToCenter = _vector2.default.sub(sphere.center, ray.origin);\n\t  var v = _vector2.default.dot(eyeToCenter, ray.direction);\n\t  var eoDot = _vector2.default.dot(eyeToCenter, eyeToCenter);\n\t  var discriminant = sphere.radius * sphere.radius - eoDot + v * v;\n\t\n\t  if (discriminant < 0) {\n\t    return;\n\t  }\n\t\n\t  return v - Math.sqrt(discriminant);\n\t}\n\t\n\tfunction sphereNormal(sphere, pos) {\n\t  return _vector2.default.normalize(_vector2.default.sub(pos, sphere.center));\n\t}\n\t\n\texports.sphereIntersection = sphereIntersection;\n\texports.sphereNormal = sphereNormal;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _vector = __webpack_require__(1);\n\t\n\tvar _vector2 = _interopRequireDefault(_vector);\n\t\n\tvar _objects = __webpack_require__(2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Renderer = function () {\n\t  function Renderer(canvas, generateSceneCallback) {\n\t    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n\t        _ref$traceDepthLimit = _ref.traceDepthLimit,\n\t        traceDepthLimit = _ref$traceDepthLimit === undefined ? 3 : _ref$traceDepthLimit,\n\t        _ref$enableSampling = _ref.enableSampling,\n\t        enableSampling = _ref$enableSampling === undefined ? false : _ref$enableSampling,\n\t        _ref$numSamples = _ref.numSamples,\n\t        numSamples = _ref$numSamples === undefined ? 9 : _ref$numSamples;\n\t\n\t    _classCallCheck(this, Renderer);\n\t\n\t    var width = canvas.width,\n\t        height = canvas.height;\n\t\n\t\n\t    this.canvas = canvas;\n\t    this.context = canvas.getContext('2d');\n\t    this.data = this.context.getImageData(0, 0, width, height);\n\t    this.generateScene = generateSceneCallback;\n\t    this.traceDepthLimit = traceDepthLimit;\n\t    this.enableSampling = enableSampling;\n\t    this.numSamples = numSamples;\n\t    this.isPlaying = false;\n\t    this.time = 1;\n\t  }\n\t\n\t  _createClass(Renderer, [{\n\t    key: 'render',\n\t    value: function render(scene) {\n\t      var camera = scene.camera;\n\t      var _canvas = this.canvas,\n\t          width = _canvas.width,\n\t          height = _canvas.height;\n\t\n\t      var data = this.data;\n\t\n\t      // all the raytracing stuff goes here\n\t\n\t      var eyeVector = _vector2.default.normalize(_vector2.default.sub(camera.direction, camera.point)); // w (reversed?)\n\t      var vpRight = _vector2.default.normalize(_vector2.default.cross(eyeVector, _vector2.default.UP)); // u\n\t      var vpUp = _vector2.default.normalize(_vector2.default.cross(vpRight, eyeVector)); // v\n\t\n\t      var fovRadians = Math.PI * (camera.fieldOfView / 2) / 180;\n\t      var heightWidthRatio = height / width;\n\t      var halfWidth = Math.tan(fovRadians);\n\t      var halfHeight = heightWidthRatio * halfWidth;\n\t      var cameraWidth = halfWidth * 2;\n\t      var cameraHeight = halfHeight * 2;\n\t      var pixelWidth = cameraWidth / (width - 1);\n\t      var pixelHeight = cameraHeight / (height - 1);\n\t\n\t      var ray = { origin: camera.point, direction: _vector2.default.new() };\n\t\n\t      for (var x = 0; x < width; x++) {\n\t        for (var y = 0; y < height; y++) {\n\t          var color = _vector2.default.copy(_vector2.default.ZERO);\n\t\n\t          if (this.enableSampling) {\n\t            var n = Math.sqrt(this.numSamples);\n\t\n\t            for (var p = 0; p < n; p++) {\n\t              for (var q = 0; q < n; q++) {\n\t                // turn the raw pixel x and y values into values from -1 to 1\n\t                // and use these values to scale the facing-right and facing-up\n\t                // vectors so that we generate versions of the `eyeVector` that are\n\t                // skewed in each necessary direction.\n\t                var xv = pixelWidth * (x - halfWidth + (q + Math.random()) / n) - halfWidth;\n\t                var yv = pixelHeight * (y - halfHeight + (p + Math.random()) / n) - halfHeight;\n\t                var xComp = _vector2.default.mult(vpRight, xv);\n\t                var yComp = _vector2.default.mult(vpUp, yv);\n\t\n\t                ray.direction = _vector2.default.normalize(_vector2.default.add3(xComp, yComp, eyeVector));\n\t\n\t                color = _vector2.default.add(color, this.trace(ray, scene, 0));\n\t              }\n\t            }\n\t\n\t            color = _vector2.default.div(color, this.numSamples);\n\t          } else {\n\t            var _xv = pixelWidth * (x - halfWidth) - halfWidth;\n\t            var _yv = pixelHeight * (y - halfHeight) - halfHeight;\n\t            var _xComp = _vector2.default.mult(vpRight, _xv);\n\t            var _yComp = _vector2.default.mult(vpUp, _yv);\n\t\n\t            ray.direction = _vector2.default.normalize(_vector2.default.add3(_xComp, _yComp, eyeVector));\n\t            color = this.trace(ray, scene, 0);\n\t          }\n\t\n\t          var index = x * 4 + y * width * 4;\n\t          data.data[index + 0] = color.x;\n\t          data.data[index + 1] = color.y;\n\t          data.data[index + 2] = color.z;\n\t          data.data[index + 3] = 255;\n\t        }\n\t      }\n\t\n\t      this.context.putImageData(data, 0, 0);\n\t    }\n\t  }, {\n\t    key: 'trace',\n\t    value: function trace(ray, scene, depth) {\n\t      if (depth > this.traceDepthLimit) {\n\t        return;\n\t      }\n\t\n\t      var _intersectScene = this.intersectScene(ray, scene),\n\t          _intersectScene2 = _slicedToArray(_intersectScene, 2),\n\t          dist = _intersectScene2[0],\n\t          object = _intersectScene2[1];\n\t\n\t      if (dist === Infinity) {\n\t        return _vector2.default.copy(_vector2.default.WHITE);\n\t      }\n\t\n\t      // The pointAtTime is another way of saying the 'intersection point'\n\t      // of this ray into this object. We compute this by simply taking\n\t      // the direction of the ray and making it as long as the distance\n\t      // returned by the intersection check.\n\t      var pointAtTime = _vector2.default.add(_vector2.default.mult(ray.direction, dist), ray.origin);\n\t\n\t      return this.surface(ray, scene, object, pointAtTime, (0, _objects.calculateNormal)(object, pointAtTime), depth);\n\t    }\n\t  }, {\n\t    key: 'intersectScene',\n\t    value: function intersectScene(ray, scene) {\n\t      return scene.objects.reduce(function (closest, object) {\n\t        var dist = (0, _objects.calculateIntersection)(object, ray);\n\t        return dist !== undefined && dist < closest[0] ? [dist, object] : closest;\n\t      }, [Infinity, null]);\n\t    }\n\t  }, {\n\t    key: 'surface',\n\t    value: function surface(ray, scene, object, pointAtTime, normal, depth) {\n\t      var color = _vector2.default.copy(_vector2.default.ZERO);\n\t      var lambertAmount = 0;\n\t\n\t      if (object.material.lambert) {\n\t        for (var i = 0; i < scene.lights.length; i++) {\n\t          var lightPoint = scene.lights[i];\n\t\n\t          // First: can we see the light? If not, this is a shadowy area\n\t          // and it gets no light from the lambert shading process.\n\t          if (!this.isLightVisible(pointAtTime, scene, lightPoint)) {\n\t            continue;\n\t          }\n\t          // Otherwise, calculate the lambertian reflectance, which\n\t          // essentially is a 'diffuse' lighting system - direct light\n\t          // is bright, and from there, less direct light is gradually,\n\t          // beautifully, less light.\n\t          var contribution = _vector2.default.dot(_vector2.default.normalize(_vector2.default.sub(lightPoint, pointAtTime)), normal);\n\t          // sometimes this formula can return negatives, so we check:\n\t          // we only want positive values for lighting.\n\t          if (contribution > 0) {\n\t            lambertAmount += contribution;\n\t          }\n\t        }\n\t      }\n\t\n\t      if (object.material.specular) {\n\t        // This is basically the same thing as what we did in render(), just\n\t        // instead of looking from the viewpoint of the camera, we're looking\n\t        // from a point on the surface of a shiny object, seeing what it sees\n\t        // and making that part of a reflection.\n\t        var reflectedRay = { origin: pointAtTime, direction: _vector2.default.reflectThrough(ray.direction, normal) };\n\t        var reflectedColor = this.trace(reflectedRay, scene, depth + 1);\n\t        if (reflectedColor) {\n\t          color = _vector2.default.add(color, _vector2.default.mult(reflectedColor, object.material.specular));\n\t        }\n\t      }\n\t\n\t      // lambert should never 'blow out' the lighting of an object,\n\t      // even if the ray bounces between a lot of things and hits lights\n\t      lambertAmount = Math.min(1, lambertAmount);\n\t\n\t      // Ambient colors shine bright regardless of whether there's a light visible -\n\t      // a circle with a totally ambient blue color will always just be a flat blue\n\t      // circle.\n\t      color = _vector2.default.add(color, _vector2.default.mult(object.color, lambertAmount * object.material.lambert));\n\t      color = _vector2.default.add(color, _vector2.default.mult(object.color, object.material.ambient));\n\t      return color;\n\t    }\n\t  }, {\n\t    key: 'isLightVisible',\n\t    value: function isLightVisible(point, scene, light) {\n\t      var ray = { origin: point, direction: _vector2.default.normalize(_vector2.default.sub(point, light)) };\n\t\n\t      var _intersectScene3 = this.intersectScene(ray, scene),\n\t          _intersectScene4 = _slicedToArray(_intersectScene3, 1),\n\t          dist = _intersectScene4[0];\n\t\n\t      return dist > -0.005;\n\t    }\n\t  }, {\n\t    key: 'tick',\n\t    value: function tick() {\n\t      var scene = this.generateScene(this.time);\n\t      this.time++;\n\t\n\t      this.render(scene);\n\t\n\t      if (this.isPlaying) {\n\t        requestAnimationFrame(this.tick.bind(this));\n\t      }\n\t    }\n\t  }, {\n\t    key: 'play',\n\t    value: function play() {\n\t      if (this.isPlaying) {\n\t        return;\n\t      }\n\t      this.isPlaying = true;\n\t      requestAnimationFrame(this.tick.bind(this));\n\t    }\n\t  }, {\n\t    key: 'stop',\n\t    value: function stop() {\n\t      this.isPlaying = false;\n\t    }\n\t  }]);\n\t\n\t  return Renderer;\n\t}();\n\t\n\texports.default = Renderer;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t// # Vector Operations\n\t//\n\t// These are general-purpose functions that deal with vectors - in this case,\n\t// three-dimensional vectors represented as objects in the form\n\t//\n\t//     { x, y, z }\n\t//\n\t// Since we're not using traditional object oriented techniques, these\n\t// functions take and return that sort of logic-less object, so you'll see\n\t// `add(a, b)` rather than `a.add(b)`.\n\t//\n\t// Heavily cribbed from:\n\t//   https://github.com/processing/p5.js/blob/master/src/math/p5.Vector.js\n\t//   https://github.com/tmcw/literate-raytracer/blob/gh-pages/vector.js\n\t\n\tvar Vector = {};\n\t\n\t// # Constants\n\tVector.UP = { x: 0.0, y: 1.0, z: 0.0 };\n\tVector.ZERO = { x: 0.0, y: 0.0, z: 0.0 };\n\tVector.WHITE = { x: 255, y: 255, z: 255 };\n\t\n\tVector.new = function () {\n\t  var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\t  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\t  var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\t\n\t  return { x: x, y: y, z: z };\n\t};\n\t\n\tVector.copy = function (a) {\n\t  return { x: a.x, y: a.y, z: a.z };\n\t};\n\t\n\tVector.dot = function (a, b) {\n\t  return a.x * b.x + a.y * b.y + a.z * b.z;\n\t};\n\t\n\tVector.cross = function (a, b) {\n\t  return {\n\t    x: a.y * b.z - a.z * b.y,\n\t    y: a.z * b.x - a.x * b.z,\n\t    z: a.x * b.y - a.y * b.x\n\t  };\n\t};\n\t\n\tVector.mult = function (a, t) {\n\t  return {\n\t    x: a.x * t,\n\t    y: a.y * t,\n\t    z: a.z * t\n\t  };\n\t};\n\t\n\tVector.div = function (a, t) {\n\t  return {\n\t    x: a.x / t,\n\t    y: a.y / t,\n\t    z: a.z / t\n\t  };\n\t};\n\t\n\tVector.normalize = function (a) {\n\t  var mag = Vector.mag(a);\n\t  return mag === 0 ? a : Vector.div(a, mag);\n\t};\n\t\n\t// Add two vectors to each other, by simply combining each\n\t// of their components\n\tVector.add = function (a, b) {\n\t  return {\n\t    x: a.x + b.x,\n\t    y: a.y + b.y,\n\t    z: a.z + b.z\n\t  };\n\t};\n\t\n\t// A version of `add` that adds three vectors at the same time. While\n\t// it's possible to write a clever version of `Vector.add` that takes\n\t// any number of arguments, it's not fast, so we're keeping it simple and\n\t// just making two versions.\n\tVector.add3 = function (a, b, c) {\n\t  return {\n\t    x: a.x + b.x + c.x,\n\t    y: a.y + b.y + c.y,\n\t    z: a.z + b.z + c.z\n\t  };\n\t};\n\t\n\t// Subtract one vector from another, by subtracting each component\n\tVector.sub = function (a, b) {\n\t  return {\n\t    x: a.x - b.x,\n\t    y: a.y - b.y,\n\t    z: a.z - b.z\n\t  };\n\t};\n\t\n\t// Length, or magnitude, measured by [Euclidean norm](https://en.wikipedia.org/wiki/Euclidean_vector#Length)\n\tVector.mag = function (a) {\n\t  return Math.sqrt(Vector.dot(a, a));\n\t};\n\t\n\tVector.angleBetween = function (a, b) {\n\t  return Math.acos(Vector.dot(a, b) / (Vector.mag(a) * Vector.mag(b))); // in radians\n\t};\n\t\n\t// Given a vector `a`, which is a point in space, and a `normal`, which is\n\t// the angle the point hits a surface, returna  new vector that is reflect\n\t// off of that surface\n\tVector.reflectThrough = function (a, normal) {\n\t  var d = Vector.mult(normal, Vector.dot(a, normal));\n\t  return Vector.sub(Vector.mult(d, 2), a);\n\t};\n\t\n\tVector.dist = function (a, b) {\n\t  var d = Vector.sub(b, a);\n\t  return Vector.mag(d);\n\t};\n\t\n\tVector.equal = function (a, b) {\n\t  return a.x === b.x && a.y === b.y && a.z === b.z;\n\t};\n\t\n\tVector.lerp = function (a, b, amount) {\n\t  return {\n\t    x: a.x + (b.x - a.x) * amount || 0,\n\t    y: a.y + (b.y - a.y) * amount || 0,\n\t    z: a.z + (b.z - a.z) * amount || 0\n\t  };\n\t};\n\t\n\tVector.setMag = function (a, n) {\n\t  return Vector.mult(Vector.normalize(a), n);\n\t};\n\t\n\tVector.limit = function (a, max) {\n\t  var magSq = Vector.dot(a, a);\n\t  if (magSq > max * max) {\n\t    return Vector.setMag(a, max);\n\t  } else {\n\t    return a;\n\t  }\n\t};\n\t\n\tVector.heading = function (a) {\n\t  return Math.atan2(a.y, a.x); // in radians\n\t};\n\t\n\tVector.rotate = function (a, angle) {\n\t  var newHeading = Vector.heading(a) + angle;\n\t  var mag = Vector.mag(a);\n\t  return {\n\t    x: Math.cos(newHeading) * mag,\n\t    y: Math.sin(newHeading) * mag,\n\t    z: a.z\n\t  };\n\t};\n\t\n\tVector.toString = function (a) {\n\t  return \"[\" + a.x + \", \" + a.y + \", \" + a.z + \"]\";\n\t};\n\t\n\tVector.toArray = function (a) {\n\t  return [a.x, a.y, a.z];\n\t};\n\t\n\texports.default = Vector;\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 44d048cd5887b5c77176","import Vector from './vector'\nimport Renderer from './renderer'\n\nconst canvas = document.getElementById('canvas')\nconst width = 640 * 0.5\nconst height = 480 * 0.5\n\ncanvas.width = width\ncanvas.height = height\ncanvas.style.cssText = `width:${(width * 2)}px;height:${(height * 2)}px`\n\nfunction generateScene(progress) {\n  const scene = {\n    camera: {\n      point: { x: 0.0, y: 1.8, z: 10 },\n      fieldOfView: 45,\n      direction: { x: 0.0, y: 3.0, z: 0.0 }\n    },\n    lights: [{ x: -30, y: -10, z: 20 }],\n    objects: [\n      {\n        type: 'sphere',\n        center: { x: 0, y: 3.5, z: -3 },\n        radius: 3,\n        color: { x: 155, y: 200, z: 155 },\n        material: {\n          specular: 0.2,\n          lambert: 0.7,\n          ambient: 0.1\n        }\n      },\n      {\n        type: 'sphere',\n        center: {\n          x: Math.sin(progress * 0.1) * 3.5,\n          y: 2,\n          z: -3 + (Math.cos(progress * 0.1) * 3.5)\n        },\n        radius: 0.2,\n        color: { x: 155, y: 155, z: 155 },\n        material: {\n          specular: 0.1,\n          lambert: 0.9,\n          ambient: 0.0\n        }\n      },\n      {\n        type: 'sphere',\n        center: {\n          x: Math.sin(progress * 0.2) * 4,\n          y: 3,\n          z: -3 + (Math.cos(progress * 0.2) * 4)\n        },\n        radius: 0.1,\n        color: { x: 255, y: 255, z: 255 },\n        material: {\n          specular: 0.2,\n          lambert: 0.7,\n          ambient: 0.1\n        }\n      }\n    ]\n  }\n\n  return scene\n}\n\nconst renderer = new Renderer(canvas, generateScene, { enableSampling: false })\n\nrenderer.tick()\n\ndocument.getElementById('play').onclick = renderer.play.bind(renderer)\ndocument.getElementById('stop').onclick = renderer.stop.bind(renderer)\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","// import VectorClass from './vector-class'\nimport VectorObjects from './vector-objects'\n\nexport default VectorObjects\n\n\n\n// WEBPACK FOOTER //\n// ./src/vector/index.js","import { sphereIntersection, sphereNormal } from './sphere'\n\nfunction calculateIntersection(object, ray) {\n  if (!object.type) {\n    throw new Error('Object has no type.')\n  }\n\n  switch(object.type) {\n    case 'sphere':\n      return sphereIntersection(object, ray)\n    default:\n      throw new Error('Invalid object type.')\n  }\n}\n\nfunction calculateNormal(object, pos) {\n  if (!object.type) {\n    throw new Error('Object has no type.')\n  }\n\n  switch(object.type) {\n    case 'sphere':\n      return sphereNormal(object, pos)\n    default:\n      throw new Error('Invalid object type.')\n  }\n}\n\nexport {\n  calculateIntersection,\n  calculateNormal\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/objects/index.js","import Vector from '../vector'\n\nfunction sphereIntersection(sphere, ray) {\n  const eyeToCenter = Vector.sub(sphere.center, ray.origin)\n  const v = Vector.dot(eyeToCenter, ray.direction)\n  const eoDot = Vector.dot(eyeToCenter, eyeToCenter)\n  const discriminant = (sphere.radius * sphere.radius) - eoDot + (v * v)\n\n  if (discriminant < 0) {\n    return\n  }\n\n  return v - Math.sqrt(discriminant)\n}\n\nfunction sphereNormal(sphere, pos) {\n  return Vector.normalize(Vector.sub(pos, sphere.center))\n}\n\nexport {\n  sphereIntersection,\n  sphereNormal\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/objects/sphere.js","import Vector from './vector'\nimport { calculateIntersection, calculateNormal } from './objects'\n\nexport default class Renderer {\n  constructor(canvas, generateSceneCallback, { traceDepthLimit=3, enableSampling=false, numSamples=9 } = {}) {\n    const { width, height } = canvas\n\n    this.canvas = canvas\n    this.context = canvas.getContext('2d')\n    this.data = this.context.getImageData(0, 0, width, height)\n    this.generateScene = generateSceneCallback\n    this.traceDepthLimit = traceDepthLimit\n    this.enableSampling = enableSampling\n    this.numSamples = numSamples\n    this.isPlaying = false\n    this.time = 1\n  }\n\n  render(scene) {\n    const camera = scene.camera\n    const { width, height } = this.canvas\n    const data = this.data\n\n    // all the raytracing stuff goes here\n\n    const eyeVector = Vector.normalize(Vector.sub(camera.direction, camera.point)) // w (reversed?)\n    const vpRight = Vector.normalize(Vector.cross(eyeVector, Vector.UP)) // u\n    const vpUp = Vector.normalize(Vector.cross(vpRight, eyeVector)) // v\n\n    const fovRadians = Math.PI * (camera.fieldOfView / 2) / 180\n    const heightWidthRatio = height / width\n    const halfWidth = Math.tan(fovRadians)\n    const halfHeight = heightWidthRatio * halfWidth\n    const cameraWidth = halfWidth * 2\n    const cameraHeight = halfHeight * 2\n    const pixelWidth = cameraWidth / (width - 1)\n    const pixelHeight = cameraHeight / (height - 1)\n\n    const ray = { origin: camera.point, direction: Vector.new() }\n\n    for (let x = 0; x < width; x++) {\n      for (let y = 0; y < height; y++) {\n        let color = Vector.copy(Vector.ZERO)\n\n        if (this.enableSampling) {\n          const n = Math.sqrt(this.numSamples)\n\n          for (let p = 0; p < n; p++) {\n            for (let q = 0; q < n; q++) {\n              // turn the raw pixel x and y values into values from -1 to 1\n              // and use these values to scale the facing-right and facing-up\n              // vectors so that we generate versions of the `eyeVector` that are\n              // skewed in each necessary direction.\n              const xv = pixelWidth * (x - halfWidth + (q + Math.random()) / n) - halfWidth\n              const yv = pixelHeight * (y - halfHeight + (p + Math.random()) / n) - halfHeight\n              const xComp = Vector.mult(vpRight, xv)\n              const yComp = Vector.mult(vpUp, yv)\n\n              ray.direction = Vector.normalize(Vector.add3(xComp, yComp, eyeVector))\n\n              color = Vector.add(color, this.trace(ray, scene, 0))\n            }\n          }\n\n          color = Vector.div(color, this.numSamples)\n\n        } else {\n          const xv = pixelWidth * (x - halfWidth) - halfWidth\n          const yv = pixelHeight * (y - halfHeight) - halfHeight\n          const xComp = Vector.mult(vpRight, xv)\n          const yComp = Vector.mult(vpUp, yv)\n\n          ray.direction = Vector.normalize(Vector.add3(xComp, yComp, eyeVector))\n          color = this.trace(ray, scene, 0)\n        }\n\n        const index = (x * 4) + (y * width * 4)\n        data.data[index + 0] = color.x\n        data.data[index + 1] = color.y\n        data.data[index + 2] = color.z\n        data.data[index + 3] = 255\n      }\n    }\n\n    this.context.putImageData(data, 0, 0)\n  }\n\n  trace(ray, scene, depth) {\n    if (depth > this.traceDepthLimit) {\n      return\n    }\n\n    const [dist, object] = this.intersectScene(ray, scene)\n\n    if (dist === Infinity) {\n      return Vector.copy(Vector.WHITE)\n    }\n\n    // The pointAtTime is another way of saying the 'intersection point'\n    // of this ray into this object. We compute this by simply taking\n    // the direction of the ray and making it as long as the distance\n    // returned by the intersection check.\n    const pointAtTime = Vector.add(Vector.mult(ray.direction, dist), ray.origin)\n\n    return this.surface(ray, scene, object, pointAtTime, calculateNormal(object, pointAtTime), depth)\n  }\n\n  intersectScene(ray, scene) {\n    return scene.objects.reduce(function(closest, object) {\n      const dist = calculateIntersection(object, ray)\n      return dist !== undefined && dist < closest[0] ? [dist, object] : closest\n    }, [Infinity, null])\n  }\n\n  surface(ray, scene, object, pointAtTime, normal, depth) {\n    let color = Vector.copy(Vector.ZERO)\n    let lambertAmount = 0\n\n    if (object.material.lambert) {\n      for (let i = 0; i < scene.lights.length; i++) {\n        const lightPoint = scene.lights[i]\n\n        // First: can we see the light? If not, this is a shadowy area\n        // and it gets no light from the lambert shading process.\n        if (!this.isLightVisible(pointAtTime, scene, lightPoint)) {\n          continue\n        }\n        // Otherwise, calculate the lambertian reflectance, which\n        // essentially is a 'diffuse' lighting system - direct light\n        // is bright, and from there, less direct light is gradually,\n        // beautifully, less light.\n        const contribution = Vector.dot(Vector.normalize(Vector.sub(lightPoint, pointAtTime)), normal)\n        // sometimes this formula can return negatives, so we check:\n        // we only want positive values for lighting.\n        if (contribution > 0) {\n          lambertAmount += contribution\n        }\n      }\n    }\n\n    if (object.material.specular) {\n      // This is basically the same thing as what we did in render(), just\n      // instead of looking from the viewpoint of the camera, we're looking\n      // from a point on the surface of a shiny object, seeing what it sees\n      // and making that part of a reflection.\n      const reflectedRay = { origin: pointAtTime, direction: Vector.reflectThrough(ray.direction, normal) }\n      const reflectedColor = this.trace(reflectedRay, scene, depth + 1)\n      if (reflectedColor) {\n        color = Vector.add(color, Vector.mult(reflectedColor, object.material.specular))\n      }\n    }\n\n    // lambert should never 'blow out' the lighting of an object,\n    // even if the ray bounces between a lot of things and hits lights\n    lambertAmount = Math.min(1, lambertAmount)\n\n    // Ambient colors shine bright regardless of whether there's a light visible -\n    // a circle with a totally ambient blue color will always just be a flat blue\n    // circle.\n    color = Vector.add(color, Vector.mult(object.color, lambertAmount * object.material.lambert))\n    color = Vector.add(color, Vector.mult(object.color, object.material.ambient))\n    return color\n  }\n\n  isLightVisible(point, scene, light) {\n    const ray = { origin: point, direction: Vector.normalize(Vector.sub(point, light)) }\n    const [dist] = this.intersectScene(ray, scene)\n    return dist > -0.005\n  }\n\n  tick() {\n    const scene = this.generateScene(this.time)\n    this.time++\n\n    this.render(scene)\n\n    if (this.isPlaying) {\n      requestAnimationFrame(this.tick.bind(this))\n    }\n  }\n\n  play() {\n    if (this.isPlaying) {\n      return\n    }\n    this.isPlaying = true\n    requestAnimationFrame(this.tick.bind(this))\n  }\n\n  stop() {\n    this.isPlaying = false\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/renderer.js","// # Vector Operations\n//\n// These are general-purpose functions that deal with vectors - in this case,\n// three-dimensional vectors represented as objects in the form\n//\n//     { x, y, z }\n//\n// Since we're not using traditional object oriented techniques, these\n// functions take and return that sort of logic-less object, so you'll see\n// `add(a, b)` rather than `a.add(b)`.\n//\n// Heavily cribbed from:\n//   https://github.com/processing/p5.js/blob/master/src/math/p5.Vector.js\n//   https://github.com/tmcw/literate-raytracer/blob/gh-pages/vector.js\n\nconst Vector = {}\n\n// # Constants\nVector.UP = { x: 0.0, y: 1.0, z: 0.0 }\nVector.ZERO = { x: 0.0, y: 0.0, z: 0.0 }\nVector.WHITE = { x: 255, y: 255, z: 255 }\n\nVector.new = function(x = 0, y = 0, z = 0) {\n  return { x: x, y: y, z: z }\n}\n\nVector.copy = function(a) {\n  return { x: a.x, y: a.y, z: a.z }\n}\n\nVector.dot = function(a, b) {\n  return (a.x * b.x) + (a.y * b.y) + (a.z * b.z)\n}\n\nVector.cross = function(a, b) {\n  return {\n    x: (a.y * b.z) - (a.z * b.y),\n    y: (a.z * b.x) - (a.x * b.z),\n    z: (a.x * b.y) - (a.y * b.x)\n  }\n}\n\nVector.mult = function(a, t) {\n  return {\n    x: a.x * t,\n    y: a.y * t,\n    z: a.z * t\n  }\n}\n\nVector.div = function(a, t) {\n  return {\n    x: a.x / t,\n    y: a.y / t,\n    z: a.z / t\n  }\n}\n\nVector.normalize = function(a) {\n  const mag = Vector.mag(a)\n  return mag === 0 ? a : Vector.div(a, mag)\n}\n\n// Add two vectors to each other, by simply combining each\n// of their components\nVector.add = function(a, b) {\n  return {\n    x: a.x + b.x,\n    y: a.y + b.y,\n    z: a.z + b.z\n  }\n}\n\n// A version of `add` that adds three vectors at the same time. While\n// it's possible to write a clever version of `Vector.add` that takes\n// any number of arguments, it's not fast, so we're keeping it simple and\n// just making two versions.\nVector.add3 = function(a, b, c) {\n  return {\n    x: a.x + b.x + c.x,\n    y: a.y + b.y + c.y,\n    z: a.z + b.z + c.z\n  }\n}\n\n// Subtract one vector from another, by subtracting each component\nVector.sub = function(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y,\n    z: a.z - b.z\n  }\n}\n\n// Length, or magnitude, measured by [Euclidean norm](https://en.wikipedia.org/wiki/Euclidean_vector#Length)\nVector.mag = function(a) {\n  return Math.sqrt(Vector.dot(a, a))\n}\n\nVector.angleBetween = function(a, b) {\n  return Math.acos(Vector.dot(a, b) / (Vector.mag(a) * Vector.mag(b))) // in radians\n}\n\n// Given a vector `a`, which is a point in space, and a `normal`, which is\n// the angle the point hits a surface, returna  new vector that is reflect\n// off of that surface\nVector.reflectThrough = function(a, normal) {\n  const d = Vector.mult(normal, Vector.dot(a, normal))\n  return Vector.sub(Vector.mult(d, 2), a)\n}\n\nVector.dist = function(a, b) {\n  const d = Vector.sub(b, a)\n  return Vector.mag(d)\n}\n\nVector.equal = function(a, b) {\n  return a.x === b.x && a.y === b.y && a.z === b.z\n}\n\nVector.lerp = function(a, b, amount) {\n  return {\n    x: a.x + (b.x - a.x) * amount || 0,\n    y: a.y + (b.y - a.y) * amount || 0,\n    z: a.z + (b.z - a.z) * amount || 0\n  }\n}\n\nVector.setMag = function(a, n) {\n  return Vector.mult(Vector.normalize(a), n)\n}\n\nVector.limit = function(a, max) {\n  const magSq = Vector.dot(a, a)\n  if (magSq > max * max) {\n    return Vector.setMag(a, max)\n  } else {\n    return a\n  }\n}\n\nVector.heading = function(a) {\n  return Math.atan2(a.y, a.x) // in radians\n}\n\nVector.rotate = function(a, angle) {\n  const newHeading = Vector.heading(a) + angle\n  const mag = Vector.mag(a)\n  return {\n    x: Math.cos(newHeading) * mag,\n    y: Math.sin(newHeading) * mag,\n    z: a.z\n  }\n}\n\nVector.toString = function(a) {\n  return `[${a.x}, ${a.y}, ${a.z}]`\n}\n\nVector.toArray = function(a) {\n  return [a.x, a.y, a.z]\n}\n\nexport default Vector\n\n\n\n// WEBPACK FOOTER //\n// ./src/vector/vector-objects.js"],"sourceRoot":""}